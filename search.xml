<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo升级教程</title>
      <link href="2020/Hexo%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B.html"/>
      <url>2020/Hexo%E5%8D%87%E7%BA%A7%E6%95%99%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g            #全局升级hexo-cli</span><br><span class="line"></span><br><span class="line">npm install -g npm                 # 升级 npm</span><br><span class="line">npm cache clean -f                 # 清除 npm 缓存</span><br><span class="line"></span><br><span class="line">===更新 hexo: 进入 blog 目录，执行如下命令=== </span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新 package.json 中的 hexo 及个插件版本</span></span><br><span class="line">npm install -g npm-check           # 检查之前安装的插件，都有哪些是可以升级的 </span><br><span class="line">npm install -g npm-upgrade         # 升级系统中的插件</span><br><span class="line">npm-check</span><br><span class="line">npm-upgrade</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新 hexo 及所有插件</span></span><br><span class="line">npm update -g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确认 hexo 已经更新</span></span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="2020/SpringCloud.html"/>
      <url>2020/SpringCloud.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="2020/Mysql.html"/>
      <url>2020/Mysql.html</url>
      
        <content type="html"><![CDATA[<h2 id="初识MySQL"><a href="#初识MySQL" class="headerlink" title="初识MySQL"></a>初识MySQL</h2><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><h2 id="MySQL数据管理"><a href="#MySQL数据管理" class="headerlink" title="MySQL数据管理"></a>MySQL数据管理</h2><h2 id="DQL查询数据（重点）"><a href="#DQL查询数据（重点）" class="headerlink" title="DQL查询数据（重点）"></a>DQL查询数据（重点）</h2><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><h3 id="指定查询字段"><a href="#指定查询字段" class="headerlink" title="指定查询字段"></a>指定查询字段</h3><blockquote><p>distinct（去重）</p></blockquote><h3 id="where条件子句"><a href="#where条件子句" class="headerlink" title="where条件子句"></a>where条件子句</h3><blockquote><p>模糊查询：比较运算符</p></blockquote><h3 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h3><blockquote><p>JOIN 对比</p></blockquote><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="../img/2020/08/ba0b27c5d6aa2c07a64a52385d6d12d7.png"></p><h3 id="分页和排序"><a href="#分页和排序" class="headerlink" title="分页和排序"></a>分页和排序</h3><h2 id="MySQL函数"><a href="#MySQL函数" class="headerlink" title="MySQL函数"></a>MySQL函数</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>COUNT()</td><td></td></tr><tr><td>SUM()</td><td></td></tr><tr><td>AVG()</td><td></td></tr><tr><td>MAX()</td><td></td></tr><tr><td>MIN()</td><td></td></tr><tr><td>。。。</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="2020/JVM.html"/>
      <url>2020/JVM.html</url>
      
        <content type="html"><![CDATA[<h2 id="JVM常见面试题"><a href="#JVM常见面试题" class="headerlink" title="JVM常见面试题"></a>JVM常见面试题</h2><ul><li>请谈谈对JVM的理解？Java8虚拟机和之前的变化？</li><li>什么事OOM，什么事栈溢出StackOverflow？怎么分析？</li><li>JVM的常用调优参数有哪些？</li><li>内存快照如何抓取，怎么分析Dump文件？</li><li>谈谈JVM中，类加载器？</li></ul><h2 id="JVM基础"><a href="#JVM基础" class="headerlink" title="JVM基础"></a>JVM基础</h2><h3 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h3><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2020/08/image-20200810235323413.png" alt="image-20200810235323413" /><h3 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h3><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="../img/2020/08/jvm体系结构.png" alt="image-20200811181852421" style="zoom: 50%;" /><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>作用：加载Class文件</p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="E:\hexo\source\img\2020\08\image-20200811185407768.png" alt="image-20200811185407768" style="zoom: 67%;" /><ol><li><p>BootstrapClassLoader（启动类（根）加载器）</p><blockquote><p><code>c++</code>编写，加载<code>java</code>核心库 <code>java.*</code>,构造<code>ExtClassLoader</code>和<code>AppClassLoader</code>。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作</p></blockquote></li><li><p>ExtClassLoader（扩展类加载器）</p><blockquote><p><code>java</code>编写，加载扩展库，如<code>classpath</code>中的<code>jre</code> ，<code>javax.*</code>或者<code>java.ext.dir</code> 指定位置中的类，开发者可以直接使用标准扩展类加载器。</p></blockquote></li><li><p>AppClassLoader（应用程序（系统类）加载器）</p><blockquote><p><code>java</code>编写，加载程序所在的目录，如<code>user.dir</code>所在的位置的<code>class</code></p></blockquote></li><li><p>CustomClassLoader（用户自定义类加载器）</p><blockquote><p><code>java</code>编写,用户自定义的类加载器,可加载指定路径的<code>class</code>文件</p></blockquote></li></ol><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>   ​    当某个类加载器需要加载某个<code>.class</code>文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。</p><p>作用：</p><ul><li><p>防止重复加载同一个<code>.class</code>。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。</p></li><li><p>保证核心<code>.class</code>不能被篡改。通过委托方式，不会去篡改核心<code>.clas</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</p> <img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="../img/2020/08/7634245-7b7882e1f4ea5d7d.png"  /><ul><li>类加载器收到类加载的请求</li><li>将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器</li><li>启动类加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则，通知子加载器进行加载</li><li>重复步骤3</li></ul></li></ul><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱<strong>主要限制系统资源访问</strong>，那系统资源包括什么？——<code>CPU、内存、文件系统、网络</code>。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p>  所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p><h3 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h3><ul><li>凡是带了native关键字的，说明java的作用域达不到了，会去调用底层C语言的方法</li><li>会进入本地方法栈</li><li>调用本地方法和接口   Java Native Interface(JNI)</li><li>JNI作用：扩展Java的使用，融合不同的编程语言为Java所用！   最初C、C++</li><li>Java诞生的时候，C、C++横行，想要立足，必须要有调用C、C++的程序</li><li>它在内存区域总专门开辟了一块标记区域：Native Method Stack，等级native 方法</li><li>在最终执行的的时候。加载本地方法库中的方法通过JNI</li><li>举例：java程序驱动打印机、管理系统、掌握即可，在企业级应用中较为少见</li><li><a href="https://www.jianshu.com/p/76959115d486">https://www.jianshu.com/p/76959115d486</a></li></ul><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>程序计数器：Program Counter Register</p><p>​    每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向一条指令的地址，也即要执行的指令代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​    方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数、接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间。</p><p>​    静态变量，常量、类信息（构造方法、接口定义）、运行的常量池存在方法区中，但是实例变量存在堆中，和方法区无关。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>​    栈：先进后出</p><p>​    队列：先进先出</p><p>​    <img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="../img/2020/08/image-20200812195842313.png" alt="image-20200812195842313"></p><h3 id="三种JVM"><a href="#三种JVM" class="headerlink" title="三种JVM"></a>三种JVM</h3><ul><li>Sun公司 HotSpot</li><li>BEA <code>JRockit</code></li><li>IBM <code>J9 VM</code></li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Heap,一个JVM只有一个堆内存，堆内存的大小是可以调节的</p><p>类加载器读取了类文件后，一般会把什么东西放到对中？</p><p>堆内存分为三个区域：</p><ul><li>新生区</li><li>老年区</li><li>永久区</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="../img/2020/08/image-20200812210646430.png" alt="image-20200812210646430"></p><p>Gc垃圾回收，主要是在伊甸园区和养老区</p><p>假设内存满了，OOM，堆内存溢出！java.lang.OutOfMemoryError</p><p><strong>Java8之后，永久区改为元空间</strong></p><h3 id="新生区、老年区"><a href="#新生区、老年区" class="headerlink" title="新生区、老年区"></a>新生区、老年区</h3><ul><li>类：诞生和成长的地方，甚至死亡；</li><li>伊甸园，所有的对象都是在伊甸园区new出来的！</li><li>幸存区（0，1）</li></ul><p>在新生区活下来的对象就进入老年区</p><h3 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h3><p>这个区域常驻内存，用来存放JDK自身携带的Class对象，Interface元数据，存储的是java运行时的一些环境或信息，这个区域不存在垃圾回收！关闭Vm虚拟机就会释放这个区域的内存</p><ul><li>jdk1.6之前 ：永久代，常量池是在方法区</li><li>jdk1.7         ：永久代，但是慢慢的退化了，<code>去永久代</code>，常量池在堆中</li><li>jdk1.8之后 ：无永久代，常量池在元空间</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="E:\hexo\source\img\2020\08\image-20200812214950926.png" alt="image-20200812214950926"></p><h3 id="堆内存调优"><a href="#堆内存调优" class="headerlink" title="堆内存调优"></a>堆内存调优</h3><p>默认情况下：分配的总内存是电脑内存的1/4，而初始化的内存是1/64</p><ul><li>尝试扩大堆内存查看结果</li><li>分析内容，看一下哪个地方出现问题</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m -Xmx1024m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>Xmx2g</td><td>JVM最大可用内存为2g</td></tr><tr><td>Xms2g</td><td>JVM初始内存2g，避免gc后JVM动态分配内存</td></tr><tr><td>Xmn1g</td><td>JVM年轻代大小</td></tr><tr><td>Xss256k</td><td>每个线程的堆栈大小</td></tr><tr><td>-XX:PermSize</td><td>永久代初始值</td></tr><tr><td>-XX:MaxPermSize</td><td>永久代最大值</td></tr></tbody></table><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>   常用算法</p><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="2020/Docker.html"/>
      <url>2020/Docker.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。</p><h3 id="Docker为什么出现"><a href="#Docker为什么出现" class="headerlink" title="Docker为什么出现"></a>Docker为什么出现</h3><p>一款产品：开发–上线  两套环境，配置环境非常麻烦。</p><p>传统：开发jar，运维部署上线</p><p>现在：开发打包部署上线，一套流程做完！</p><p>Docker的思想来自集装箱：打包隔离，每个箱子是相互隔离的！</p><h3 id="Docker的历史"><a href="#Docker的历史" class="headerlink" title="Docker的历史"></a>Docker的历史</h3><p>2010年，几个年轻人，在美国成立了一家公司dotCloud，做一些 pass 的云计算服务，LXC有关的容器技术。</p><p>2013年，Docker开源，于是越来越多的人发现它的优点！</p><p>2014年4月9日，Docker1.0发布！</p><h3 id="Docker能干嘛？"><a href="#Docker能干嘛？" class="headerlink" title="Docker能干嘛？"></a>Docker能干嘛？</h3><p>####虚拟化技术</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2020/07/image-20200715234446807.png" alt="虚拟化技术结构图"></p><p>虚拟机技术缺点：</p><p>1、资源占用多</p><p>2、冗余步骤多</p><p>3、启动慢</p><h4 id="容器化技术"><a href="#容器化技术" class="headerlink" title="容器化技术"></a>容器化技术</h4><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2020/07/image-20200715235125873.png" alt="容器化技术结构图"></p><p>比较Docker和虚拟机技术的不同：</p><ul><li>传统虚拟机虚拟处一个硬件，运行一个完整的操作系统，在系统上安装和运行软件</li><li>容器内的应用直接运行在宿主主机的内容，容器是没有自己的内核的，也没有虚拟出硬件，所以就轻便了</li><li>每个容器间是相互隔离，每个容器内都有一个属于自己的文件系统，互不影响</li></ul><h4 id="DevOps（开发、运维）"><a href="#DevOps（开发、运维）" class="headerlink" title="DevOps（开发、运维）"></a>DevOps（开发、运维）</h4><p><strong>应用更快速的交付和部署</strong></p><p>传统：一堆帮助文档、安装程序</p><p>Docker：打包镜像发布测试，一键运行</p><p><strong>更便捷的升级和扩缩容</strong></p><p><strong>更简单的系统运维</strong></p><p><strong>更高效的计算资源利用</strong></p><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><h3 id="Docker基本组成"><a href="#Docker基本组成" class="headerlink" title="Docker基本组成"></a>Docker基本组成</h3><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2020/07/image-20200723210803208.png" alt="image-20200723210803208"></p><ul><li><p>镜像(image)：一个模板，可以通过模板来创建容器服务，Tomcat镜像===&gt;run===&gt;Tomcat01容器（提供服务），通过这个镜像可以创建多个容器（最终项目运行在容器中）</p></li><li><p>容器(container)：利用容器技术，独立运行一个或一组应用，通过镜像来创建。</p><p>启动、停止、删除、基本命令！</p></li><li><p>仓库(repository)：仓库就是存放镜像的地方！仓库分为公有和私有！</p></li></ul><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ol><li>一点linux基础</li><li>centos7</li><li>Xshell远程连接</li></ol><h4 id="环境查看"><a href="#环境查看" class="headerlink" title="环境查看"></a>环境查看</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">系统内核是3.10以上</span></span><br><span class="line">[root@localhost /]# uname -r</span><br><span class="line">3.10.0-862.14.4.el7.x86_64</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">系统版本</span></span><br><span class="line">[root@localhost /]# cat /etc/os-release </span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;7&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line">CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;</span><br><span class="line">HOME_URL=&quot;https://www.centos.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>帮助文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、卸载旧版本</span></span><br><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">                  </span><br><span class="line"><span class="meta">#</span><span class="bash">2、需要的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3、设置镜像的仓库</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo #（国外地址，速度慢）</span><br><span class="line">    </span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">更新yum软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4、安装docker</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">5、启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">6、判断是否安装成功</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">7、hello-world</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">8、查看hello-world镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p>了解：卸载docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、卸载依赖</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2、删除资源</span></span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">/var/lib/docker  （docker的默认工作路径）</span></span><br></pre></td></tr></table></figure><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2020/07/image-20200723222317676.png" alt="image-20200723222317676" style="zoom: 80%;" /><p>配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://cn12gl5r.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="hello-world的流程"><a href="#hello-world的流程" class="headerlink" title="hello-world的流程"></a>hello-world的流程</h3><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2020/07/image-20200723222951013.png" alt="image-20200723222951013"></p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="Docker是怎么工作的？、"><a href="#Docker是怎么工作的？、" class="headerlink" title="Docker是怎么工作的？、"></a>Docker是怎么工作的？、</h4><p>Docker是一个client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问！</p><p>DockerServer接收到DockerClient的指令，就会执行这个命令。</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2020/07/image-20200723224028879.png" alt="image-20200723224028879"></p><h4 id="Docker为什么比vm块"><a href="#Docker为什么比vm块" class="headerlink" title="Docker为什么比vm块"></a>Docker为什么比vm块</h4><ol><li>Docker有比虚拟机更少的抽象层</li><li>Docker利用的是宿主主机的内核，vm需要Guest-OS</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2020/07/image-20200723225148222.png" alt="image-20200723225148222"></p><p>所以，新建一个容器的时候，Docker不需要像虚拟机一样重新加载操作系统内核，避免引导，虚拟机是加载GuestOS，</p><h2 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version      #显示docker的版本信息</span><br><span class="line">docker info         #显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker 命令 --help   #帮助命令</span><br></pre></td></tr></table></figure><p>帮助文档地址：<a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><p><strong>docker images  查看所有本地主机的镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        6 months ago        13.3kB</span><br><span class="line"><span class="meta">#</span><span class="bash">仓库源              标签                id                  创建时间             大小</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可选项</span></span><br><span class="line">-a, --all         #列出所有镜像</span><br><span class="line">-q, --quiet       #只显示镜像的id</span><br></pre></td></tr></table></figure><p><strong>docker search 搜索镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker search mysql</span><br><span class="line">NAME     DESCRIPTION                                     STARS     OFFICIAL  AUTOMATED</span><br><span class="line">mysql    MySQL is a widely used, open-source relation…   9760      [OK]               </span><br><span class="line">mariadb  MariaDB is a community-developed fork of MyS…   3564      [OK]</span><br><span class="line"><span class="meta">#</span><span class="bash">可选项，通过搜索过滤</span></span><br><span class="line">--filter=STARS=3000  #过滤STARS=3000以上的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>docker pull  下载镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">docker pull mysql [:tag]</span></span><br><span class="line">[root@localhost ~]# docker pull mysql</span><br><span class="line">Using default tag: latest #如果不写，默认latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">6ec8c9369e08: Pull complete  #分层下载，docker image的核心，联合文件系统</span><br><span class="line">177e5de89054: Pull complete </span><br><span class="line">ab6ccb86eb40: Pull complete </span><br><span class="line">e1ee78841235: Pull complete </span><br><span class="line">09cd86ccee56: Pull complete </span><br><span class="line">78bea0594a44: Pull complete </span><br><span class="line">caf5f529ae89: Pull complete </span><br><span class="line">cf0fc09f046d: Pull complete </span><br><span class="line">4ccd5b05a8f6: Pull complete </span><br><span class="line">76d29d8de5d4: Pull complete </span><br><span class="line">8077a91f5d16: Pull complete </span><br><span class="line">922753e827ec: Pull complete </span><br><span class="line">Digest: sha256:fb6a6a26111ba75f9e8487db639bc5721d4431beba4cd668a4e922b8f8b14acc</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure><p><strong>docker rmi 删除镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker rmi -f 8679ced16d20  #删除指定的镜像</span><br><span class="line">[root@localhost ~]# docker rmi -f id1 id2 id3 id4  #批量删除镜像</span><br><span class="line">[root@localhost ~]# docker rmi -f $(docker images -aq) #删除全部镜像</span><br></pre></td></tr></table></figure><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p><strong>说明：</strong>有了镜像才可以创建爱你容器，下载一个centos测试学习</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><p><strong>新建容器并启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">参数说明</span></span><br><span class="line">--name=&quot;Name&quot;    容器名字  ，用于区分容器</span><br><span class="line">-d               后台方式运行</span><br><span class="line">-it              使用交互方式运行，进入容器查看内容</span><br><span class="line">-p               指定容器的端口</span><br><span class="line">-p  ip:主机端口:容器端口</span><br><span class="line">-p  主机端口：容器端口</span><br><span class="line">-p  容器端口</span><br><span class="line">容器端口</span><br><span class="line">-P               随机指定端口</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">测试、启动并进入容器</span></span><br><span class="line">[root@localhost ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@0d7b4443e40f /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从容器返回主机</span></span><br><span class="line">[root@0d7b4443e40f /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost /]# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><p><strong>列出所有运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">docker ps</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">列出当前正在运行的容器</span></span><br><span class="line">-a    #列出所有容器，包括运行和停止的</span><br><span class="line">-n=?  #显示最近创建的容器</span><br><span class="line">-q    #只显示容器编号</span><br><span class="line">[root@localhost /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@localhost /]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">0d7b4443e40f        centos              &quot;/bin/bash&quot;         3 minutes ago       Exited (0) 3 minutes ago                       funny_brown</span><br><span class="line">488f714c3556        bf756fb1ae65        &quot;/hello&quot;            3 days ago          Exited (0) 3 days ago                          boring_antonelli</span><br></pre></td></tr></table></figure><p><strong>退出容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit    #直接停止容器并退出</span><br><span class="line">Ctrl + P + Q  #容器不停止直接退出</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm  容器id               #删除指定的容器，不能删除正在运行的容器</span><br><span class="line">docker rm -f $(docker ps -aq)   #删除所有容器</span><br><span class="line">docker ps -a -qixargs docker rm #删除所有容器</span><br></pre></td></tr></table></figure><p><strong>启动和停止容器的操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start  容器id     #启动容器</span><br><span class="line">docker restart  容器id   #重启容器</span><br><span class="line">docker stop  容器id      #停止当前正在运行的容器</span><br><span class="line">docker kill  容器id      #强制停止当前容器</span><br></pre></td></tr></table></figure><h3 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h3><p><strong>后台启动容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令 docker run -d 镜像名</span></span><br><span class="line">[root@localhost /]# docker run -d centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">问题：docker ps ，发现centos停止了</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker 容器使用后台运行，就必须有一个前台进程，docker发现没有前台应用，就会停止</span></span><br></pre></td></tr></table></figure><p><strong>查看日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail 数量 容器id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">自己写一点shell脚本</span></span><br><span class="line">[root@localhost /]# docker run -d centos /bin/sh -c &quot;while true;do echo sen;sleep 1;done&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示日志</span></span><br><span class="line">-tf     #显示日志</span><br><span class="line">--tail number  #要显示日志条数</span><br><span class="line">[root@localhost /]# docker logs -tf --tail 10 5b6</span><br></pre></td></tr></table></figure><p><strong>查看容器中进程信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">docker top 容器id</span></span><br><span class="line">[root@localhost /]# docker top 5b6</span><br><span class="line">UID                 PID                 PPID                C                   STIME           </span><br><span class="line">root                5028                5011                0                   23:34           </span><br><span class="line">root                5414                5028                0                   23:39    </span><br></pre></td></tr></table></figure><p><strong>查看镜像的元数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">docker inspect 容器id</span></span><br><span class="line"></span><br><span class="line">[root@localhost /]# docker inspect 5b6</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;5b6bb141ff8dbd7b2d4b23179cf776cd8655869ddce3a66718ff4f48dbf04a48&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2020-07-26T15:34:32.646214144Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/sh&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;while true;do echo sen;sleep 1;done&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 5028,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2020-07-26T15:34:34.106610567Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:831691599b88ad6cc2a4abbd0e89661a121aff14cfa289ad840fd3946f274f1f&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/5b6bb141ff8dbd7b2d4b23179cf776cd8655869ddce3a66718ff4f48dbf04a48/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/5b6bb141ff8dbd7b2d4b23179cf776cd8655869ddce3a66718ff4f48dbf04a48/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/5b6bb141ff8dbd7b2d4b23179cf776cd8655869ddce3a66718ff4f48dbf04a48/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/5b6bb141ff8dbd7b2d4b23179cf776cd8655869ddce3a66718ff4f48dbf04a48/5b6bb141ff8dbd7b2d4b23179cf776cd8655869ddce3a66718ff4f48dbf04a48-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/hardcore_wu&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;Capabilities&quot;: null,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;KernelMemory&quot;: 0,</span><br><span class="line">            &quot;KernelMemoryTCP&quot;: 0,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: null,</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/c843700f0413b2c16dd5b8ef5b92c198a93ae988f16bd76893987a478fc2fcd8-init/diff:/var/lib/docker/overlay2/d19e4335d150c3ac104d757d8a08c503acd7a9785c0312184fd0a6c40ad20c0d/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/c843700f0413b2c16dd5b8ef5b92c198a93ae988f16bd76893987a478fc2fcd8/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/c843700f0413b2c16dd5b8ef5b92c198a93ae988f16bd76893987a478fc2fcd8/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/c843700f0413b2c16dd5b8ef5b92c198a93ae988f16bd76893987a478fc2fcd8/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;5b6bb141ff8d&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;while true;do echo sen;sleep 1;done&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;centos&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20200611&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;7235922c0b4e7cdb5882da90036c0549af0996234d1d071ae5d877059642dcc5&quot;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/7235922c0b4e&quot;,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;f0bbfc96cd4bea48f9168cb2aa3fc5e47f788711579116c633245d7f9e8c69f8&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;b1a5cb7bce7dabc316af738756e70532ce2f4a3a244007b6a483309b4b2f0723&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;f0bbfc96cd4bea48f9168cb2aa3fc5e47f788711579116c633245d7f9e8c69f8&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                    &quot;DriverOpts&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>进入当前正在运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方式1：docker <span class="built_in">exec</span> -it 容器id bashshell</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker exec -it 30f /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方式2：docker attach 容器id</span></span><br><span class="line">[root@localhost ~]# docker attach 30f</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">docker <span class="built_in">exec</span>     进入容器后开启一个新的终端，可以在里面操作（常用）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker attach   进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure><p><strong>从容器内复制文件到主机上</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">docker cp 容器id:容器内路径  目的的主机路径</span></span><br><span class="line">[root@localhost /]# docker cp 211:/home/test.java /home</span><br><span class="line">[root@localhost /]# cd home</span><br><span class="line">[root@localhost home]# ls</span><br><span class="line">sen  sen.java  test.java  transmission</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">复制是一个手动过程，未来使用-v卷技术，可以实现自动同步数据</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="../img/2020/07/image-20200727162953284.png" alt="image-20200727162953284"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拦截器</title>
      <link href="2020/%E6%8B%A6%E6%88%AA%E5%99%A8.html"/>
      <url>2020/%E6%8B%A6%E6%88%AA%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><p>1、添加jar包</p><p>2、配置文件(spring-config.xml、spring-mvc.xml、jdbc.propertoes、log4j.properties)</p><p>3、各层(pojo、mapper、service、controller)</p><p>4、页面</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理</title>
      <link href="2019/%E4%BB%A3%E7%90%86.html"/>
      <url>2019/%E4%BB%A3%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>把自己要做的事委托给别人完成</p><p>静态代理：只能代理一件事情</p><p>动态代理：代理多件事情</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ul><li>真实对象和代理对象都要实现同一个接口</li><li>代理对象要代理真实角色</li></ul><p>好处：</p><p>​        代理对象可以做很多真实对象做不了的事情</p><p>​        真实对象专注做自己的事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeddingCompany weddingCompany = <span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You());</span><br><span class="line">        weddingCompany.happyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;要结婚了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Marry target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="keyword">this</span>.target.happyMarry();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="2019/Spring.html"/>
      <url>2019/Spring.html</url>
      
        <content type="html"><![CDATA[<p>1、spring入门</p><p>2、springIOC</p><p>3、Setter和构造器注入(DI)</p><p>4、面向切面编程/面向抽象编程</p><p>5、Bean的作用域与Bean的生命周期    </p><p>6、内置bean配置之数据源</p><p>7、基于注解的IOC配置</p><p>8、代理模式 – 静态代理、动态代理</p><p>9、springAOP入门</p><p>10、springAOP事务管理</p><p>11、spring整合mybatis</p><p>IOC【Inversion Of Control】控制反转：把本来自己控制的事件，交给spring管理，交出控制权</p><p>DI【Dependency InJection】依赖注入：</p><p>​        setter注入和构造器注入，来管理(IOC获取的控制权)</p><h2 id="自动装配："><a href="#自动装配：" class="headerlink" title="自动装配："></a>自动装配：</h2><p>autowire(bean标签)、default-autowire(beans标签)：其值有byName、byType、constructor</p><h2 id="懒加载（延迟加载）："><a href="#懒加载（延迟加载）：" class="headerlink" title="懒加载（延迟加载）："></a>懒加载（延迟加载）：</h2><p>在bean标签中书写lazy-init，其值有true-延迟加载，false(默认)spring启动时立即加载</p><h2 id="bean【标签】的生命周期和作用域"><a href="#bean【标签】的生命周期和作用域" class="headerlink" title="bean【标签】的生命周期和作用域"></a>bean【标签】的生命周期和作用域</h2><h4 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h4><p>init-method：对象初始化之后执行的指定方法</p><p>destroy-method：在对象销毁前执行的指定方法</p><h4 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a>作用域：</h4><p>singleton：每一个bean对应一个实例(单例模式、默认配置)</p><p>prototype：每一次获取一个新的实例(一般web中控制层对象一个配置为该值)</p><p>request：在web项目中，针对每一次请求都创建一个bean实例</p><p>session：在web项目中，针对每一次回话创建一个bean实例</p><p>global-session：在web项目中，针对所有客户端的请求始终只创建一个bean(application)</p><h2 id="bean的name和id"><a href="#bean的name和id" class="headerlink" title="bean的name和id"></a>bean的name和id</h2><h4 id="bean注解配置："><a href="#bean注解配置：" class="headerlink" title="bean注解配置："></a>bean注解配置：</h4><p>1、引入spring的基础jar，和spring-aop.jar</p><p>2、在spring核心配置中引用配置spring-context</p><p>3、在spring核心配置中配置：&lt;context:annotation-config /&gt;</p><p>4、在Java类中使用注解</p><p>​    @Autowire 默认根据bean的类型解析装配，其次根据name进行装配</p><p>​    @Qualifier 当自动配置名不一致时，进行微调    （@Resource）</p><p>​    @Component 标记当前类为一个被spring容器管理的Bean，可以细化：</p><p>​    @Repository  用于注解数据持久层(DAO、Mappper)</p><p>​    @Service  用于注解业务逻辑层(Service)</p><p>​    @Controller  用于注解控制层(controller)</p><p>​    @Param 参数</p><p>​    其它注解：</p><p>​    @PostConstruct  生命周期-初始化  (写在方法上面)</p><p>​    @PreDestroy   生命周期–销毁   (写在方法上面)</p><p>​    @Scope  初始化次数(单例模式、多例，写在类上面)</p><p>​    @Lazy  延迟加载  (写在类上面)</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解和反射</title>
      <link href="2019/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84.html"/>
      <url>2019/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84.html</url>
      
        <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>Java5.0发布</p><p>java.Annotation</p><p>由来</p><p>定义方式</p><p>使用方法</p><p>JDK5定义的Annotation注解</p><p>注解：可以在不影响java源程序的情况下，通过标注的方式在类、方法、属性上起到一定的作用；然后通过一些解析工具(比如反射)对其解析，然后实行特定功能。</p><h2 id="常见的注解"><a href="#常见的注解" class="headerlink" title="常见的注解"></a>常见的注解</h2><p><strong>@Override</strong></p><p>标注在方法上，为子类重写父类的方法；检查是否为重写方法</p><p><strong>@Deprecated</strong></p><p>标注在任何地方(类、属性、方法、构造器、包…)，表示被标注的元素为过时的（不推荐使用）</p><p><strong>@SuppressWarnings</strong></p><p>忽略编译期间的警告(泛型未定义、变量未使用)</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(name = &quot;sen&quot;,age = 18)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">//注解的参数：参数类型+参数名()</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span>  -1</span>;</span><br><span class="line"></span><br><span class="line">    String[] schools() <span class="keyword">default</span> &#123;<span class="string">&quot;清华大学&quot;</span>,<span class="string">&quot;北京大学&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元注解："><a href="#元注解：" class="headerlink" title="元注解："></a>元注解：</h2><p>JDK5提供的修饰注解的元注解，只能修饰注解，不能修饰非注解的对象</p><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>​    注解的保留位置(source,class,runtime)</p><ol><li>RetentionPolicy.CLASS 编译器会将该注解保留在字节码文件中，但不会保留在JVM中，所以无法通过反射机制读取到注解信息</li><li>RetentionPolicy.SOURCE 该注解只在源代码中保留，作为标记使用，编译时会丢弃</li><li>RetentionPolicy.RUNTIME 编译器会将注解保留在字节码文件中，同时在JVM中也进行保留，所有可以通过反射机制读取到注解信息</li></ol><h3 id="Target-声明注解使用的位置"><a href="#Target-声明注解使用的位置" class="headerlink" title="@Target 声明注解使用的位置"></a>@Target 声明注解使用的位置</h3><ul><li>ElementType.TYPE 修饰类。接口</li><li>ElementType.FIELD  修饰属性(全局变量)</li><li>ElementType.CONSTRUCTOR   修饰构造器</li><li>ElementType.METHOD   修饰方法</li><li>ElementType.PACKAGE   修饰包</li><li>ElementType.PARAMETER   修饰参数</li><li>ElementType.LOCAL_VARIABLE  修饰局部变量</li><li>使用过该注解的元素被子类继承时能够同时继承该注解</li></ul><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>如果需要将注解信息生成到Javadoc时可以使用该注解</p><p>###@Inherited</p><p>使用过该注解的元素被子类继承时能够同时继承该注解</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射是java中类的一种自省机制，通过反射可以在运行时获取类中的成分，并且使用，从而提高了java的动态性；java中任何一个类都有一个对应的java.lang.Class对象，这个对象包含了类中的所有成分（属性，构造器，方法，注解等），获取类的Class对象有几种方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Test03 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        Person person &#x3D; new Student();</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;方式1：通过对象获得</span><br><span class="line">        Class c1 &#x3D; person.getClass();</span><br><span class="line">        System.out.println(c1.hashCode());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;方式2：通过forname后的</span><br><span class="line">        Class c2 &#x3D; Class.forName(&quot;org.example.Student&quot;);</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;方式3：通过.class获得</span><br><span class="line">        Class c3 &#x3D; Student.class;</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;方式4：基本内置类型的包装类都有一个TYPE属性</span><br><span class="line">        Class c4 &#x3D; Integer.TYPE;</span><br><span class="line">        System.out.println(c4);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;后的父类类型</span><br><span class="line">        Class c5 &#x3D; c1.getSuperclass();</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哪些类型可以有Class对象："><a href="#哪些类型可以有Class对象：" class="headerlink" title="哪些类型可以有Class对象："></a>哪些类型可以有Class对象：</h3><ul><li>class：外部类，成员</li><li>insterface：接口</li><li>[]：数组</li><li>enum：枚举</li><li>annotation：注解@interface</li><li>primitive type：基本数据类型</li><li>void</li></ul><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p><strong>加载</strong>：</p><p>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类java.lang.Class对象。</p><p><strong>链接</strong>：</p><p>将Java类的二进制代码合并到JVM的运行状态中的过程</p><ul><li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li><li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li><li>解析：虚拟机常量池的符号引用（常量名）替换为直接引用（地址）的过程</li></ul><p><strong>初始化：</strong></p><ul><li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）</li><li>当初始化一个类的时候，如果发现其父类还没有初始化，则要先触发其父类的初始化。</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁和同步。</li></ul><h3 id="什么时候会发生类的初始化"><a href="#什么时候会发生类的初始化" class="headerlink" title="什么时候会发生类的初始化"></a>什么时候会发生类的初始化</h3><p><strong>类的主动引用</strong>（一定会发生类的初始化）</p><ul><li>当虚拟机启动，先初始化main方法所在的类</li><li>new一个类的对象</li><li>调用类的静态成员（除了final常量）和静态方法</li><li>使用java.lang.reflect包的方法对类进行反射调用</li><li>当初始化一个类，如果其父类没有被初始化，则先初始化其父类</li></ul><p><strong>类被动引用（不会发生类的初始化）</strong></p><ul><li>当访问一个静态域时，只有真正声明这个域的类才会被初始化</li><li>通过数组定义类引用，不会触发此类的初始化</li><li>引用常量不会触发此类的初始化</li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><strong>类加载器的作用</strong></p><p>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类java.lang.Class对象，作为方法区中类数据的访问入口。</p><p><strong>类加载器的种类</strong></p><ul><li>引导类加载器：用C++编写，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取。</li><li>扩展类加载器：负责jre/lib/ext目录下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库</li><li>系统类加载器：负责java -claddpath或-D java.class.path所指的目录下的类与jar包装入工作，是最常用的类加载器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML和XML</title>
      <link href="2019/HTML%E5%92%8CXML.html"/>
      <url>2019/HTML%E5%92%8CXML.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTML和XML"><a href="#HTML和XML" class="headerlink" title="HTML和XML"></a>HTML和XML</h2><p>html和xml都属于SGML（标准通用标记语言）的分支</p><p>html–程序型标记（html5不属于SGML）</p><p>xml–描述型语言（1998成为标准）</p><p>两者都是W3C维护</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>xml:Extensible Markup Language,可扩展标记语言，xml只代表数据本身，而不包含任何样式，所以也称为一种描述语言</p><h3 id="xml的作用"><a href="#xml的作用" class="headerlink" title="xml的作用"></a>xml的作用</h3><ol><li>实现不同平台之间的数据交互（webservice）</li><li>xml可以用于一些应用程序的配置文件（tomcat、servlet、web.xml）</li></ol><h3 id="xml的作用-1"><a href="#xml的作用-1" class="headerlink" title="xml的作用"></a>xml的作用</h3><ol><li>xml指令：&lt;?xml version=”1.0” encoding=”UTF-8”&gt;</li><li>文档类型定义&lt;!DOCTYPE&gt;</li><li>文档元素部分</li></ol><h3 id="xml指令"><a href="#xml指令" class="headerlink" title="xml指令"></a>xml指令</h3><p>主要描述xml版本（目前只有1.0），编码，文档是否定义为一个独立的文件。</p><p>文档类型（DTD,XSD）：规范文档中允许出现的标记，属性，以及标记之间的关系。</p><p>文档内容构成部分：标签、属性、文本。规范：标记必须成对出现，严格区分大小写</p><h2 id="DOM解析"><a href="#DOM解析" class="headerlink" title="DOM解析"></a>DOM解析</h2><p>需要将被解析的文档完整的加载到内存中，解析为一颗倒置的树，可以通过解析器任意获取</p><p>文档树种的节点</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>适合解析较小的文档，解析速度快，可以任意搜索节点，并行搜索</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>一次性加载整个文档，会消耗大量内存，无法解析较大文档</p><h2 id="SAX解析："><a href="#SAX解析：" class="headerlink" title="SAX解析："></a>SAX解析：</h2><p>​    基于事件驱动的方式，一流媒体方式解析解析，在读取到一部分内容之后立即开始解析，直</p><p>到读取到文档的结束标记后停止解析。</p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>可以解析较大文档，解析效率快，一边读一边解析</p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>无法任意加载搜索节点，比较难实现并行搜索</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目搭建</title>
      <link href="2019/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA.html"/>
      <url>2019/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA.html</url>
      
        <content type="html"><![CDATA[<h2 id="项目搭建流程"><a href="#项目搭建流程" class="headerlink" title="项目搭建流程"></a>项目搭建流程</h2><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><h3 id="2、新建数据库"><a href="#2、新建数据库" class="headerlink" title="2、新建数据库"></a>2、新建数据库</h3><h3 id="3、搭建项目"><a href="#3、搭建项目" class="headerlink" title="3、搭建项目"></a>3、搭建项目</h3><h4 id="①、Tomcat"><a href="#①、Tomcat" class="headerlink" title="①、Tomcat"></a>①、Tomcat</h4><h4 id="②、jar"><a href="#②、jar" class="headerlink" title="②、jar"></a>②、jar</h4><h4 id="③、配置文件"><a href="#③、配置文件" class="headerlink" title="③、配置文件"></a>③、配置文件</h4><h4 id="④、导入页面"><a href="#④、导入页面" class="headerlink" title="④、导入页面"></a>④、导入页面</h4><h4 id="⑤、java目录"><a href="#⑤、java目录" class="headerlink" title="⑤、java目录"></a>⑤、java目录</h4><p>​            com.工程名称.模块名称.dto</p><p>​                                .dao</p><p>​                                .daoImp</p><p>​                                .service</p><p>​                                .serviceImp</p><p>​                                .servlet</p><p>​                                .fifter</p><h4 id="⑥、测试"><a href="#⑥、测试" class="headerlink" title="⑥、测试"></a>⑥、测试</h4><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src=""></p><h2 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h2><h3 id="1、需求"><a href="#1、需求" class="headerlink" title="1、需求"></a>1、需求</h3><pre><code>#### ①用户</code></pre><p>​    对用户进行注册，登录，安全退出，修改个人信息，删除个人信息，查询个人信息</p><p>​    身份：</p><p>​        游客：能够访问那些页面，index，注册，登录</p><p>​        会员：功能，安全退出，修改个人信息，删除个人信息，查询个人信息</p><p>​        管理员：修改个人信息，删除个人信息，查询个人信息</p><p>查询所有会员信息并操作</p><h4 id="②、商品"><a href="#②、商品" class="headerlink" title="②、商品"></a>②、商品</h4><p>​    添加页面</p><p>​    展示所有页面</p><p>​    添加到购物车</p><p>​    生成订单—支付</p><p>表结构</p><h3 id="2、建项目"><a href="#2、建项目" class="headerlink" title="2、建项目"></a>2、建项目</h3><p>①、建表</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsp笔记</title>
      <link href="2019/jsp%E7%AC%94%E8%AE%B0.html"/>
      <url>2019/jsp%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>JSP=HTML+Java (java server pages):在服务器上运行的页面</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注释内容 --&gt;    JSP的显示注释</span><br><span class="line"></span><br><span class="line">&lt;%-- 注释内容 --%&gt;   JSP的隐藏注释</span><br></pre></td></tr></table></figure><h2 id="Java的书写"><a href="#Java的书写" class="headerlink" title="Java的书写"></a>Java的书写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%       %&gt;     JSP中插入Java代码(不能写方法)</span><br><span class="line"></span><br><span class="line">&lt;%!      %&gt;     JSP声明：静态块、变量、方法</span><br><span class="line"></span><br><span class="line">&lt;%=      %&gt;     JSP表达式 ：向页面输出内容(等价于out.println();)  </span><br></pre></td></tr></table></figure><h2 id="三个指令"><a href="#三个指令" class="headerlink" title="三个指令"></a>三个指令</h2><h3 id="①、page指令-lt-page-属性-”值”-…-gt"><a href="#①、page指令-lt-page-属性-”值”-…-gt" class="headerlink" title="①、page指令  &lt;%@ page 属性=”值” … %&gt;"></a>①、page指令  &lt;%@ page 属性=”值” … %&gt;</h3><p>​    属性1：import=”java.util.<em>, java.io.</em>“;  导包<br>​    属性2：pageEncoding  告诉JSP引擎要翻译的文件使用的编码方式<br>​    属性3：contentType 声明当前文件的类型及编码方式 ，等同于（服务器响应给用户的数据的编码方式）-response.setContentType(“text/html;charset=utf-8”);<br>​    属性4：errorPage：如果页面有错误，则跳转到指定资源(页面维护中….)<br>​            errorPage=”/uri”;  “/“：绝对路径，代表当前应用下的目录；””：不写/，表示相对路径<br>​    属性5：isErrorPage：是否创建throwable对象，默认false</p><h3 id="②、include指令-静态包含-其它页面"><a href="#②、include指令-静态包含-其它页面" class="headerlink" title="②、include指令      静态包含(其它页面)"></a>②、include指令      静态包含(其它页面)</h3><p>​    1)、静态包含(指令) &lt;%@ include file=”页面路径” %&gt;<br>​        在编译时，把两个文件合并起来一起编译<br>​        多用：一般处理页面的header、footer部分</p><p>​    2)、动态包含(动作指令)  &lt;jsp:include page=”页面路径”&gt;</jsp:include><br>​        不会合并，当代码执行到包含时，才包含另一个文件</p><h3 id="③、taglib"><a href="#③、taglib" class="headerlink" title="③、taglib"></a>③、taglib</h3><p>​    JSTL：标签标签库的使用</p><h2 id="六个动作指令"><a href="#六个动作指令" class="headerlink" title="六个动作指令"></a>六个动作指令</h2><h3 id="①、动态包含-动作指令"><a href="#①、动态包含-动作指令" class="headerlink" title="①、动态包含(动作指令)"></a>①、动态包含(动作指令)</h3><p>​    &lt;jsp:include page=”页面路径”&gt;</jsp:include></p><p>​    不会合并，当代码执行到包含时，才包含另一个文件</p><h3 id="②、请求转发-jsp-forward-服务器跳转："><a href="#②、请求转发-jsp-forward-服务器跳转：" class="headerlink" title="②、请求转发  jsp:forward  服务器跳转："></a>②、请求转发  <a href="jsp:forward">jsp:forward</a>  服务器跳转：</h3><p>​    地址栏不变，页面内容跳转，可以带参数(客户端跳转：地址栏及页面内容都跳转，不能带参数)</p><h3 id="③、设置请求参数-jsp-param"><a href="#③、设置请求参数-jsp-param" class="headerlink" title="③、设置请求参数  jsp:param"></a>③、设置请求参数  <a href="jsp:param">jsp:param</a></h3><h3 id="④、创建一个对象-jsp-useBean"><a href="#④、创建一个对象-jsp-useBean" class="headerlink" title="④、创建一个对象  jsp:useBean"></a>④、创建一个对象  <a href="jsp:useBean">jsp:useBean</a></h3><h3 id="⑤、给指定的对象属性赋值-jsp-setProperty"><a href="#⑤、给指定的对象属性赋值-jsp-setProperty" class="headerlink" title="⑤、给指定的对象属性赋值 jsp:setProperty"></a>⑤、给指定的对象属性赋值 <a href="jsp:setProperty">jsp:setProperty</a></h3><h3 id="⑥、取出指定对象的属性值-jsp-getProperty"><a href="#⑥、取出指定对象的属性值-jsp-getProperty" class="headerlink" title="⑥、取出指定对象的属性值 jsp:getProperty"></a>⑥、取出指定对象的属性值 <a href="jsp:getProperty">jsp:getProperty</a></h3><h2 id="九个内置对象"><a href="#九个内置对象" class="headerlink" title="九个内置对象"></a>九个内置对象</h2><h3 id="1、request-HttpServletRequest-："><a href="#1、request-HttpServletRequest-：" class="headerlink" title="1、request(HttpServletRequest)："></a>1、request(HttpServletRequest)：</h3><p>​    该对象封装了1个请求，客户端的所有信息</p><p>​    全部封装在该对象中，那么我们就可以定义该对象中的方法，来获取到我们想要的信息</p><h3 id="2、response-HttpServletResponse-："><a href="#2、response-HttpServletResponse-：" class="headerlink" title="2、response(HttpServletResponse)："></a>2、response(HttpServletResponse)：</h3><p>​    代表服务器响应客户端</p><h3 id="3、session-HttpSession-："><a href="#3、session-HttpSession-：" class="headerlink" title="3、session(HttpSession)："></a>3、session(HttpSession)：</h3><p>​    代表一次会话，客户端与服务器的一次会话(连接)</p><p>​        会话开始：与服务器建立连接<br>​        会话结束：关闭浏览器</p><h3 id="4、application-javax-servlet-ServletContext-："><a href="#4、application-javax-servlet-ServletContext-：" class="headerlink" title="4、application(javax.servlet.ServletContext)："></a>4、application(javax.servlet.ServletContext)：</h3><p>​    代表整个web项目</p><h3 id="5、config-ServletConfig-："><a href="#5、config-ServletConfig-：" class="headerlink" title="5、config(ServletConfig)："></a>5、config(ServletConfig)：</h3><p>​    代表JSP的配置信息</p><h3 id="6、pageContext-javax-servlet-jsp-PageContext-："><a href="#6、pageContext-javax-servlet-jsp-PageContext-：" class="headerlink" title="6、pageContext(javax.servlet.jsp.PageContext)："></a>6、pageContext(javax.servlet.jsp.PageContext)：</h3><p>​    代表页面的上下文</p><h3 id="7、exception-java-lang-Throwable-："><a href="#7、exception-java-lang-Throwable-：" class="headerlink" title="7、exception(java.lang.Throwable)："></a>7、exception(java.lang.Throwable)：</h3><p>​    如果设置了错误页面，则会跳转到指定的错误页面</p><p>​    可以通过exception.getMessage()获取错误信息                    </p><h3 id="8、out-JspWriter-："><a href="#8、out-JspWriter-：" class="headerlink" title="8、out(JspWriter)："></a>8、out(JspWriter)：</h3><p>​    服务器响应页面的输出内容</p><h3 id="9、page："><a href="#9、page：" class="headerlink" title="9、page："></a>9、page：</h3><p>​    代表当前JSP页面，类似于java中的this关键字</p><h4 id="注：每次请求服务器，服务器所做的事情："><a href="#注：每次请求服务器，服务器所做的事情：" class="headerlink" title="注：每次请求服务器，服务器所做的事情："></a>注：每次请求服务器，服务器所做的事情：</h4><p>​    1.启动单独的线程</p><p>​    2.使用I/O流读取用户的请求数据</p><p>​    3.从请求数据中解析参数</p><p>​    4.处理用户的请求</p><p>​    5.生成响应的数据</p><p>​    6.使用I/O流向客户端响应数据</p><h2 id="四个存值对象的范围"><a href="#四个存值对象的范围" class="headerlink" title="四个存值对象的范围"></a>四个存值对象的范围</h2><h3 id="1、application："><a href="#1、application：" class="headerlink" title="1、application："></a>1、application：</h3><p>​    存储的值，在整个web项目过程中都有效</p><h3 id="2、session："><a href="#2、session：" class="headerlink" title="2、session："></a>2、session：</h3><p>​    仅对一次会话有效，同一次会话中，所有页面和servlet中都可以获取值；但新会话就没有值了</p><h3 id="3、request："><a href="#3、request：" class="headerlink" title="3、request："></a>3、request：</h3><p>​    仅对1次会话有效，必须结合服务器跳转才可以传值</p><p>​    //1.给request中存储值<br>​    request.setAttribute(“req_key”, “req_val”);<br>​<br>​    //2-1.服务器跳转：①地址栏不变，页面内容改变   ②可以把request范围内的值传递出去<br>​    request.getRequestDispatcher(“B.jsp”).forward(request, response);<br>​<br>​    //2-2.客户端跳转：①、地址栏和页面内容都改变   ②不能传值<br>​    response.sendRedirect(“../C.jsp”);</p><p>​    <a href="B.jsp">B页面</a>  超链接属于客户端跳转</p><h3 id="4、page："><a href="#4、page：" class="headerlink" title="4、page："></a>4、page：</h3><p>​    仅对当前页面有效</p><h2 id="request"><a href="#request" class="headerlink" title="request"></a>request</h2><p>​    1、获取文本框中的属性名及值</p><p>​    2、获取请求属性及参数</p><p>​    3、处理客户端请求服务器的编码方式</p><p>​        req.setCharacterEncoding(“utf-8”);</p><p>​    4、页面跳转</p><p>​        req.getRequestDispatcher(“页面地址”).forward(req,resp);</p><p>​        ①、地址栏不变、页面改变</p><p>​        ②、可以带参数</p><h2 id="response"><a href="#response" class="headerlink" title="response"></a>response</h2><p>​    1、向客户端响应文本—代替out</p><p>​        PrintWrite out = response.getWriter();</p><p>​        out.println(“文本内容”);</p><p>​        out.flush;</p><p>​    2、设置服务器响应客户端的编码方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html:charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>​    3、响应给客户端二进制数据</p><p>​    ServletOutputStream os = response.getOutputStream();</p><p>​    响应格式：resp.setContentType(“image/png”);</p><p>​    4、页面跳转（客户端跳转）</p><p>​        resp.sendRedirect(“页面地址”);</p><p>​        ①、地址栏和页面改变</p><p>​        ②、不能带参数</p><p>​    5、页面刷新</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>综合笔记</title>
      <link href="2019/%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0.html"/>
      <url>2019/%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>​    字母、数字、_、$</p><p>​        1、数字不能开头</p><p>​        2、区分大小写</p><p>​        3、不能是关键字</p><p>​        4、不能有空格</p><p>​        5、长度不限，见名知意</p><p>​        6、驼峰式起名(类名每个单词首字母大写、变量名首字母小写之后每个单词首字母大写)</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>​    数据类型：简单数据类型   和  引用数据类型(复合类型)</p><p>​    简单数据类型：四类八种</p><p>​        数值型：整型：byte、short、int、long         浮点型：   float、double</p><p>​        字符型：char    ‘ ‘</p><p>​        布尔型：boolean  – true/false</p><p>​    引用数据类型：类、集合、数组…</p><p>​        字符串：String   “  ”</p><h2 id="变量常量"><a href="#变量常量" class="headerlink" title="变量常量"></a>变量常量</h2><p>​    变量：在程序运行过程中值可以发生改变的量，在同一作用域范围内不能重复定义(全局变量和局部变量)</p><p>​        作用域：大括号开始到大括号结束</p><p>​        全局变量：定义在类里面，函数外面的变量</p><p>​        局部变量：定义在函数里面的变量</p><p>​    常量：用final修饰的，标识符所有字母全部大写的，且在程序运行过程中值不能发生改变的量</p><p>​        final：最终的意思</p><h2 id="转义字符-“-”"><a href="#转义字符-“-”" class="headerlink" title="转义字符   “\”"></a>转义字符   “\”</h2><p>​        \n换行、双\表示一个\、  “ \“ ”    </p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>​    单行注释：   //注释内容</p><p>​    多行注释：  /*  注释内容  */</p><p>​    文档注释：  /**</p><p>​                *    注释内容</p><p>​                */</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>​    分为：自动转换  和  强制转换</p><p>​    等级：byte、short、char  &lt;  int   &lt; long   &lt; float  &lt; double</p><p>​        自动转换：由低等级向高等级转换</p><p>​        强制转换：由高等级向低等级转换</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>​    算数运算符：+(拼接)、-、*、/、%(取余)</p><p>​    比较运算符：==、!=、&gt;、  &lt;、 &gt;=、  &lt;=     ( String的比较相等equals()方法 )</p><p>​    逻辑运算符：&amp;&amp;  &amp;：有一个为false，结果就为false</p><p>​                ||  |：有一个为true，结果就为true</p><p>​                    !：取反</p><p>​                    ^：相同为false，不同为true</p><p>​                &amp;&amp;与&amp;、||与|的区别：发生短路</p><p>​    二进制运算符：&amp;    |    ^     &lt;&lt;左移    &gt;&gt;右移</p><pre><code> 赋值运算符：+=   -=    *=    /=   %=    </code></pre><p>​    其它运算符：++、– 、  三目运算符</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>​        顺序语句</p><p>​        条件语句</p><p>​        循环语句</p><h3 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h3><p>​        分支结构：单分支，语法结构，if(boolean类型的判断条件){ if代码块  }<br>                  双分支，语法结构，if (){ if代码块 }else{ else代码块 }<br>                     多分支，语法结构，if(){ }else if(){ }else if(){ }…else{ }    </p><p>​                                    switch语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(count % <span class="number">2</span> !=<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;222&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>​        分为：一维数组  和 二维数组(多维)</p><p>​        概念：存放相同数据类型的多个值</p><p>​        定义：静态定义 和  动态定义</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>​        定义： 数据类型 []  数组名      或    数据类型   数组名[]</p><p>​        静态定义：数据类型 [] 数组名 = {值1, 值2, …….};</p><p>​                 特点：已经知道了具体的值</p><p>​                        定义与初始化不能分开写</p><p>​        动态定义：数据类型 [] 数组名 = new 数据类型[1024];</p><p>​                特点：不知道具体的值，但是规定了数组的大小(存放元素的个数)</p><p>​                      定义和初始化可以分开写</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>​        定义： 数据类型 [][]  数组名      或    数据类型   数组名[][]</p><p>​        静态定义：数据类型 [][] 数组名 = {值1, 值2, …….};</p><p>​        动态定义：数据类型 [][] 数组名 = new 数据类型[5][6];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> [][] dds = &#123;</span><br><span class="line">&#123;<span class="number">2.1</span>, <span class="number">3</span>, <span class="number">3.33</span>&#125;,</span><br><span class="line">&#123; <span class="number">4.44</span> &#125;,</span><br><span class="line">&#123;<span class="number">5.55</span>, <span class="number">6.66</span>&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出单个元素</span></span><br><span class="line">System.out.println( dds[<span class="number">2</span>][<span class="number">1</span>] );</span><br><span class="line"></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">System.out.println( dds.length );</span><br><span class="line">System.out.println( dds[<span class="number">2</span>].length );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dds.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dds[i].length; j++) &#123;</span><br><span class="line">System.out.print(dds[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>​    函数的定义：</p><p>​        定义在类里面，main函数外面；一个类里面可以定义多个函数，但不能重复定义。</p><p>​    语法结构：</p><p>​        访问修饰符   函数的返回类型    函数名( 参数  ){    函数体      }</p><p>​            访问修饰符：public(公共的)、protected(受保护)、默认、private(私有的)</p><p>​            函数的返回类型：无返回(void)  和   有返回(各种数据类型)</p><p>​            函数名：首字母小写，之后每个单词首字母大写</p><p>​            参数：用户调用函数时带过来的值，在函数体中起到作用</p><p>​            函数体：具体的代码实现过程</p><p>​    函数之间的调用：</p><p>​        main函数可以调用普通函数；普通函数之间可以相互调用；但是普通函数不能自己调用    </p><p>​    自己，会出现死循环；普通函数不能调用main函数，main函数被JVM调用，当main函数执</p><p>​    行完毕，程序结束，JVM结束运行。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>​    类和对象</p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>​            public   protected    默认    private</p><p>​            访问域不同：</p><p>​            public：公共的，谁都可以访问，访问域最大</p><p>​            private：私有的，只有当前类可以访问，访问域最小</p><p>​            默认：什么都不写，只有在同一个包中，不管是否有父子关系，都可以访</p><p>​    问； 在不同的包中，不管是否有父子关系，都不可以访问</p><p>​            protected：受保护的，在同一个包，不管是否有父子关系，都可以访</p><p>​    问；  在不同的包中，有父子关系，可以访问；没有父子关系，不能访问</p><p>​            访问域大小：</p><p>​                public  &gt;   protected   &gt;   默认   &gt; private</p><h3 id="getter-setter方法"><a href="#getter-setter方法" class="headerlink" title="getter/setter方法"></a>getter/setter方法</h3><p>​            作用：传值</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>​    抽象类：abstract修饰的类</p><p>​        作用：统一约束子类</p><p>​        抽象类里面可以有抽象方法，抽象方法是没有方法体的方法</p><p>​        抽象类不能直接实例化使用，而是通过其子类使用</p><p>​        所有继承抽象类的普通类，必须实现抽象类里面的抽象方法 – 约束子类</p><p>​        抽象类里面可以有抽象方法，也可以有普通方法，不一定必须含义抽象方法</p><p>​        含义抽象方法的类，必须声明为抽象类</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>​        java的接口是身份的象征，作用：统一约束子类</p><p>​        定义接口不在使用class，是interface，接口里面的方法是没有方法体的方法，</p><p>​    要想使用接口，必须通过实现类使用。</p><p>​        方法默认：public abstract void chaocai() ;</p><p>​        属性默认：public final int LEGS = 10; </p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>​    定义在类里面的类</p><p>​    Java的内部类：成员内部类、静态内部类、方法内部类、匿名内部类</p><h2 id="Java类库"><a href="#Java类库" class="headerlink" title="Java类库"></a>Java类库</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h3 id="封装类"><a href="#封装类" class="headerlink" title="封装类"></a>封装类</h3><p>​            简单数据类型  和 其对应的  包装类型  之间的转换</p><h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><p>​                Integer<code>类包装一个对象中的原始类型</code>int`的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.  int 转  Integer</span><br><span class="line"></span><br><span class="line">2. Integer  转   int</span><br><span class="line"></span><br><span class="line">3. String   转  int</span><br><span class="line"></span><br><span class="line">4. int   转   String</span><br><span class="line"></span><br><span class="line">5. String   转   Integer</span><br><span class="line"></span><br><span class="line">6. Integer  转   String</span><br><span class="line"></span><br><span class="line">7. Integer  转  double</span><br><span class="line"></span><br><span class="line">8. 十进制 转  八进制、十六进制</span><br></pre></td></tr></table></figure><h3 id="Double"><a href="#Double" class="headerlink" title="Double"></a>Double</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#96;Double&#96;类包装一个对象中的原始类型&#96;double&#96;的值</span><br><span class="line"></span><br><span class="line">1. double   转   Double</span><br><span class="line"></span><br><span class="line">2. Double   转  double</span><br><span class="line"></span><br><span class="line">3. String 转  double</span><br><span class="line"></span><br><span class="line">4. isNaN(double d);  如果参数不是一个数，报true；是一个数，报false。</span><br></pre></td></tr></table></figure><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#96;Character&#96;类包装一个对象中的基本类型&#96;char&#96;的值</span><br><span class="line"></span><br><span class="line">1. String  转  Char</span><br><span class="line"></span><br><span class="line">2. char 转 String</span><br></pre></td></tr></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">布尔类将对象中的基元类型&#96;boolean&#96;的值进行包装</span><br><span class="line"></span><br><span class="line">1. boolean  转  Boolean</span><br><span class="line">      2.  Boolean   转  boolean</span><br><span class="line">      3. String  转 boolean</span><br><span class="line">      4. boolean  转 String</span><br></pre></td></tr></table></figure><p>​    总结：</p><p>​        1. 简单类型  转  其包装类：使用包装类的构造函数</p><p>​             2. 包装类  转  其简单类型：【包装类对象的】标识符.***Value();</p><p>​                                char：【包装类对象的】标识符.valueOf(char c);</p><p>​        3. String  转   简单类型：包装类名.parse***(【字符串的】标识符);</p><p>​        4.  简单类型 转  String： 包装类名.toString(【简单类型的】标识符);</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>​        数组：可以存放一组相同数据类型的数据结构</p><p>​            特点：①、数组一旦创建，其长度不可改变</p><p>​                    ②、一个数组中只能存放一种数据类型的数据</p><p>​        集合：可以存放多种数据类型数据的数据结构</p><p>​            特点：①、集合的长度是可以改变的</p><p>​                    ②、对存放的数据的类型没有限制</p><p>​        在Java中，使用一些类来描述集合，这样的类我们称之为—-集合类；集合类的对象就是</p><p>​    一个集合。</p><p>​        实例化：</p><p>​                int [] arr = new int[10];</p><p>​                集合类   标识符 = new 集合类();</p><p>​        学习任务：</p><p>​            1、了解Java中集合类及它们之间的继承关系</p><p>​            2、创建集合类的对象(—-创建集合)</p><p>​            3、向集合中添加元素</p><p>​            4、获取集合中的元素(获取单个元素、删除元素)</p><p>​            5、遍历集合( 迭代器 )</p><h3 id="集合的分类"><a href="#集合的分类" class="headerlink" title="集合的分类"></a>集合的分类</h3><p>​        单值集合(v)    键值对集合(k-v)</p><p>​    <img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="" alt="![](D:\J1906\视频\day16\笔记\01-集合\01-集合分类及继承关系.png)"></p><h3 id="集合中的区别"><a href="#集合中的区别" class="headerlink" title="集合中的区别"></a>集合中的区别</h3><p>​    1、Collection 和 Collections 的区别</p><p>​        Collection是一个接口，是所有单值集合类的父接口；</p><p>​        Collections是一个帮助类，这个类中提供了很多对集合的操作的静态方法</p><p>​    2、List接口  和  Set接口   的区别</p><p>​        List接口和Set接口都是 Collection接口的子接口；</p><p>​        List集合中的元素是有序可重复的</p><p>​        Set集合中的元素是无序不可重复的</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="D:\J1906\视频\day16\笔记\01-集合\02-List&Set.png"></p><p>​    3、ArrayList 和 LinkedList  的区别</p><p>​        ArrayList集合 和 LinkedList集合都是List集合的实现类，其元素都是有序可重复的；</p><p>​        ArrayList中的元素的存储是基于数组的实现，元素查询、添加速度较快，但是插入元素</p><p>​    速度较慢；</p><p>​        LinkedList中的元素的存储是基于链表的实现，元素的插入较快，查询与添加较慢；</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="D:\J1906\视频\day16\笔记\01-集合\03-ArrayList&LinkedList区别.png"></p><p>​    4、ArrayList 和 Vector 的区别</p><p>​        ArrayList和Vector都是基于数组的存储；</p><p>​        Vector实现了同步，是线程安全的；</p><p>​        ArrayList线程非安全的，但是其存储效率较高；</p><p>​    5、HashSet 和 TreeSet 的区别</p><p>​        两者都是Set接口的实现类，其元素都是无序不可重复的；</p><p>​        区别在于其元素的存储方式不同：</p><p>​            HashSet是按照hash码散列存储；</p><p>​            TreeSet是树形存储；</p><p>​    6、HashMap 和 Hashtable的区别</p><p>​        两者都是Map接口的实现类，都表示键值对集合；</p><p>​            HashMap中允许有一个null键和多个null值；</p><p>​            Hashtable中不允许有null作为key或value；</p><p>​            HaspMap未实现同步，是线程非安全的；</p><p>​            Hashtable实现了同步，是线程安全的；</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="D:\J1906\视频\day16\笔记\01-集合\04-HashMap&Hashtable的区别.png"></p><h3 id="Collection接口中常用的方法-List-Set通用"><a href="#Collection接口中常用的方法-List-Set通用" class="headerlink" title="Collection接口中常用的方法(List/Set通用)"></a>Collection接口中常用的方法(List/Set通用)</h3><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="D:\J1906\视频\day17\笔记\01-集合\05-Collection集合中常用的方法.png"></p><h4 id="Iterator-和-ListIterator"><a href="#Iterator-和-ListIterator" class="headerlink" title="Iterator 和 ListIterator"></a>Iterator 和 ListIterator</h4><p>​        ListIterator：可以倒序遍历List集合；</p><p>​        Iterator：只能对集合中的元素进行移除操作</p><p>​        ListIterator：不仅可以移除元素，而且可以替换当前元素，或插入元素</p><h3 id="Map集合常用方法"><a href="#Map集合常用方法" class="headerlink" title="Map集合常用方法"></a>Map集合常用方法</h3><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="D:\J1906\视频\day19\笔记\01-集合\06-Map集合常用方法.png"></p><p>作业</p><table><thead><tr><th></th><th>ArrayList</th><th>HashSet</th><th>HashMap</th><th>Hashtable</th></tr></thead><tbody><tr><td>创建对象</td><td></td><td></td><td></td><td></td></tr><tr><td>添加元素</td><td></td><td></td><td></td><td></td></tr><tr><td>插入元素</td><td></td><td></td><td></td><td></td></tr><tr><td>移除元素</td><td></td><td></td><td></td><td></td></tr><tr><td>获取单个元素</td><td></td><td></td><td></td><td></td></tr><tr><td>遍历集合</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>​    Java程序运行过程中所发生的异常事件可分为两类：</p><p>​        错误(Error):JVM系统内部错误、资源耗尽等严重情况</p><p>​        异常(Exception): 其它因编程错误或偶然的外在因素导致的一般性问题，</p><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p>​    <img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="" alt="![](D:\J1906\视频\day19\笔记\02-异常\01-异常分类.png)"></p><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>​    关键字：try、catch、throw、throws、finally</p><h4 id="try-catch异常处理过程："><a href="#try-catch异常处理过程：" class="headerlink" title="try_catch异常处理过程："></a>try_catch异常处理过程：</h4><p>​        1. 如果try中的代码块不出现异常，所有代码按顺序执行，catch中的代码块不会执行，</p><p>​    finally中的代码块会执行。</p><p>​        2. 如果try中的代码块出现异常</p><p>​            ①、在异常出现之前，所有代码块按顺序正常执行</p><p>​            ②、抛出异常：一旦发现try中的代码出现异常，首先确认出现异常种类，然后创建</p><p>​        这个异常种类的对象，接着把这个异常对象提交到Java异常堆栈中</p><p>​            ③、捕获异常：Java系统一旦发现异常堆栈中有异常对象，就终止try中的代码块的    </p><p>​        执行，去寻找一个类型与该异常对象匹配的catch代码块来处理这种异常；处理完成后，</p><p>​        就接着执行catch后的代码块。</p><p>​            ④、如果没有找到类型与异常对象匹配的catch，则程序终止。</p><p>​            ⑤、finally后的代码块仍然会执行</p><p>​        3. finally后的代码块，不管try中代码块是否出现异常，都会执行</p><p>​        **final、finally、finalize()区别</p><p>​    父类异常，可以处理子类异常发生的异常情况</p><p>​    子类异常，不能处理父类异常发生的异常情况</p><p>​    处理异常时，子类在前，父类在后</p><h4 id="throws异常处理过程："><a href="#throws异常处理过程：" class="headerlink" title="throws异常处理过程："></a>throws异常处理过程：</h4><p>​        向上抛异常，谁调用谁处理</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>​    在Java的类库中，定义了很多异常类，每个异常类代表一种异常，但是这些异常类总是有限</p><p>的，当我们在实际项目开发中，有很多看似正常的情况，在具体环境下就有可能出现编程异常的</p><p>情况(比如：int i = -5;  但是在开发过程中，如果想要把 i 当做年龄来使用，那么就会有异常发生的</p><p>可能)，所以我们在很多情况下，都要自定义自己的异常处理类。</p><p>​    自定义过程：</p><p>​        1. 创建一个类，继承Exception / RuntimeException类</p><p>​        2. 在该类中重写Exception / RuntimeException类中的构造器</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正则表达式每次都要编译</span></span><br><span class="line">String str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = str.matches(<span class="string">&quot;.*2.*&quot;</span>);</span><br><span class="line">System.out.println( b1 );</span><br><span class="line"></span><br><span class="line"><span class="comment">//正则表达式一次编译，多次使用</span></span><br><span class="line"><span class="comment">//先编译正则表达式，把编译号的正则表达存放在p变量中</span></span><br><span class="line">Pattern p = Pattern.compile(<span class="string">&quot;.*a.*&quot;</span>);</span><br><span class="line"><span class="comment">//用编译好的正则表达式，匹配某个字符串</span></span><br><span class="line"><span class="comment">//返回Mather类，该类中有一个方法是用来判断是否返回要求的</span></span><br><span class="line">Matcher m = p.matcher(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"><span class="comment">//判断是否符合正则表达式规则</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = m.matches();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><p>​     []:代表一个字符，表示或的元素</p><p>​        例如：a[abc]c，表示字符串有三个字符，第一个字符是a，第二个字符是a或b或c，第</p><p>​    三个字符是c</p><p>​    [^]：表示取反        </p><p>​        a[^abc]c：第二个字符不是a或不是b或不是c，是之外的任何一个字符<br>    预定义字符</p><p>​            .  ： 表示任意一个字符</p><p>​            \d： [0-9]  任意数字</p><p>​            \s : 表示任意一个空格</p><p>​            \w:表示任意一个大小写字母</p><p>​            \: 表示一个 \</p><p>​    数量词：?   +   *  {} 修饰最接近它的前一个字符</p><p>​            ?：表示一个或没有</p><p>​            +：表示一个或多个</p><p>​            *：表示0个或多个</p><p>​            {n}：表示有n个</p><p>​            {n,}：表示至少有n个</p><p>​            {n,m}：表示至少有n个，最多有m个</p><p>​    边界： ^  $<br>             ^：开始<br>             $：结束<br>              Java的正则表达式的匹配：是完全匹配<br>             其它语言：子串匹配(JS/SQL)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcd#sadsd#dsds#sdcs&quot;</span>;</span><br><span class="line">String [] strs = str.split(<span class="string">&quot;#&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="IO的概述"><a href="#IO的概述" class="headerlink" title="IO的概述"></a>IO的概述</h3><p>​              输入、输出</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="D:\J1906\视频\day20\笔记\03-IO\01-输入、输出.png"></p><h3 id="IO的分类"><a href="#IO的分类" class="headerlink" title="IO的分类"></a>IO的分类</h3><p>​            Input/Output</p><p>​            IO流(输入/输出流)：就是和外界进行数据交互的管道</p><p>​            IO流的作用：用于程序与外界进行数据的交互</p><p>​            分类</p><p>​                根据数据传输的方向，可以将流分为：</p><p>​                    输入流：将外界的数据传入程序中</p><p>​                    输出流：将程序中的数据传出到外界</p><p>​                根据处理数据的类型，可以将流分为：</p><p>​                    字符流：以字符为单位进行数据的输入/输出</p><p>​                    字节流：以字节为单位进行数据的输入/输出</p><p>​                根据数据处理的能力，可以将流分为：</p><p>​                    节点流：低级流</p><p>​                    处理流：高级流</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="D:\J1906\视频\day20\笔记\03-IO\02-分类.png"></p><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把路径封装为一个File对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;D:/code/b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = file.exists()； <span class="comment">//判断此路径是否存在</span></span><br><span class="line">   <span class="keyword">boolean</span> b2 =  file.createNewFile(); <span class="comment">//如果不存在，创建文件(不是创建文件夹)</span></span><br><span class="line"><span class="keyword">boolean</span> b3 = file.mkdir(); <span class="comment">//创建文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b4 = file3.isFile(); <span class="comment">//判断文件存在且是一个普通文件</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = file3.isDirectory();<span class="comment">//判断文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.读写状态</span></span><br><span class="line">   <span class="keyword">boolean</span> b1 = f.canRead();<span class="comment">//是否可读</span></span><br><span class="line">   <span class="keyword">boolean</span> b2 = f.canWrite(); <span class="comment">//是否可写</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.隐藏状态</span></span><br><span class="line">   <span class="keyword">boolean</span> b3 = f.isHidden();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.获取文件内容的长度</span></span><br><span class="line">   <span class="keyword">long</span> len = f.length();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.获取文件/目录的名字</span></span><br><span class="line">   String fileName = f.getName();</span><br><span class="line">   <span class="comment">//获取文件/目录的路径</span></span><br><span class="line">   String filePath = f.getPath();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.获取当前文件/目录    的父目录</span></span><br><span class="line">   String parentPath = f.getParent();</span><br><span class="line">   File parentFile = f.getParentFile();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//6.删除</span></span><br><span class="line">   <span class="comment">//if( f.delete() ) &#123;</span></span><br><span class="line">   <span class="comment">//System.out.println(&quot;删除成功！&quot;);</span></span><br><span class="line">   <span class="comment">//&#125;else &#123;</span></span><br><span class="line">   <span class="comment">//System.out.println(&quot;删除失败！&quot;);</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//7.输出文件最后一次修改的时间(单位：毫秒)</span></span><br><span class="line">   <span class="keyword">long</span> l = f.lastModified();</span><br><span class="line">   Date d = <span class="keyword">new</span> Date(l);</span><br><span class="line"></span><br><span class="line">   System.out.println( d.toLocaleString() );</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列举出当前路径下的所有文件和文件夹(以字符串形式显示)，包括隐藏文件</span></span><br><span class="line">String [] ff = f.list();</span><br><span class="line"><span class="keyword">for</span>(String s : ff) &#123;</span><br><span class="line">System.out.println( s );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//列举出当前路径下的所有文件和文件夹(以File对象形式显示)，包括隐藏文件</span></span><br><span class="line">File [] files = f.listFiles();</span><br><span class="line"><span class="keyword">for</span>(File file : files) &#123;</span><br><span class="line">System.out.println( file.getName() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p>​    随机流</p><p>​    即是输入流，有是输出流</p><h3 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h3><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="D:\J1906\视频\day20\笔记\03-IO\03-InputStream.png"></p><h3 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h3><p>![04-OutputStream ](D:\J1906\视频\day20\笔记\03-IO\04-OutputStream .png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.io03.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04_copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String src, String dest)</span> </span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream( src );</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream( dest );</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="comment">//int k;</span></span><br><span class="line"><span class="comment">//while((k=fis.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">//fos.write(k);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="comment">//byte [] b = new byte[1024];</span></span><br><span class="line"><span class="comment">//while((fis.read(b)) != -1) &#123;</span></span><br><span class="line"><span class="comment">//fos.write(b);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：</span></span><br><span class="line"><span class="keyword">byte</span> [] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">fos.write(b, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;复制失败！&quot;</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;复制失败！&quot;</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">copyFile(<span class="string">&quot;D:/code/Test02.java&quot;</span>, <span class="string">&quot;C:/copy/eee.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><p>​        ObjectOutputStream：对象序列化，将程序中的对象输出到外界(保存数据)</p><p>​        ObjectInputStream：对象反序列化，将外界存储的对象读取到程序中</p><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h3><p>​        将计算机通过网络设备及通信线路连接在一起</p><h3 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h3><p>​            局域网(校内网)、城域网(都市网)、广域网(万维网)</p><h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>​            计算机–连接–计算机</p><p>​        <img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="" alt="![](D:\J1906\视频\day22\笔记\04-网络编程\01-拓扑结构.png)"></p><h3 id="按照传输介质划分"><a href="#按照传输介质划分" class="headerlink" title="按照传输介质划分"></a>按照传输介质划分</h3><p>​    双绞线：8细线   橙白  橙    绿白 蓝  蓝白 绿   棕白  棕   6根有用</p><p>​    同轴电缆：铜绞线</p><p>​    光导纤维、视线介质等</p><h3 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h3><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="D:\J1906\视频\day22\笔记\04-网络编程\03-通信协议.png"></p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="D:\J1906\视频\day22\笔记\04-网络编程\04-分层.png"></p><h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><p>​    该类用来描述网络中计算机地址，一个InetAddress类的对象就代表一个网络地址。</p><table><thead><tr><th>类的作用</th><th>一个InetAddress类的对象就代表一个网络地址</th></tr></thead><tbody><tr><td>构造方法</td><td>没有</td></tr><tr><td>创建对象</td><td>InetAddressInetAddress addr1 = InetAddress.getLocalHost();          InetAddress addr2 = InetAddress.getByName(“192.168.5.254”);</td></tr><tr><td>常用方法</td><td></td></tr></tbody></table><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>​    socket(套接字)：代表一个IP和port组合，也就是两个程序的连接。</p><p>​    A程序和B程序之间的通信：</p><pre><code>      1. B程序要占有一个端口号    2. 启动B程序，使其处于等待状态，等待A程序连接    3. A程序根据B程序的IP和port，向B程序发送连接请求</code></pre><table><thead><tr><th>类的作用</th><th>用于向服务端发送连接请求，通过IP和port请求建立连接</th></tr></thead><tbody><tr><td>构造方法</td><td></td></tr><tr><td>常用方法</td><td></td></tr></tbody></table><h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><p>​    </p><table><thead><tr><th>类的作用</th><th>创建一个网络服务，等待客户端来连接</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>​        进程中程序执行的多态路径</p><h3 id="开启线程"><a href="#开启线程" class="headerlink" title="开启线程"></a>开启线程</h3><p>​        第一步：</p><p>​            1、继承Thread类</p><p>​            2、实现Runnable接口</p><p>​        第二步：</p><p>​            以上两种方式，都需要重写线程类或接口中的run();</p><p>​        第三步：</p><p>​            通过线程类中的start()方法，调用重写的run()方法，开启新线程</p><p>​    main方法的执行是主线程；如果想开启多个线程，则必须在main函数中开启，如果想创建新</p><p>线程则需要线程类。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li><p>new创建线程类–&gt; 新生状态</p></li><li><p>新生状态–&gt;可以直接让它死亡–&gt;死亡状态</p></li><li><p>新生状态–&gt;就绪状态–&gt;死亡</p></li><li><p>新生状态–&gt;就绪状态–&gt;分配给时间片–&gt;运行状态–&gt;死亡</p></li><li><p>新生状态–&gt;就绪状态–&gt;分配给时间片–&gt;运行状态–&gt;调度–&gt;就绪状态–&gt;分配时间片–&gt;运行状态</p></li><li><p>新生状态–&gt;就绪状态–&gt;分配给时间片–&gt;运行状态–&gt;阻塞–&gt;阻塞状态–&gt;解除阻塞事件–&gt;就绪状态–&gt;分配时间片–&gt;运行状态</p></li><li><p>新生状态–&gt;就绪状态–&gt;分配给时间片–&gt;运行状态–&gt;阻塞–&gt;阻塞状态–&gt;死亡状态</p></li><li><p>反复就绪、调度、阻塞，直到CPU分配给足够的时间片，线程才能执行完成</p></li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>​    1、什么是数据库</p><p>​        存放数据的仓库，为了保证数据的安全性</p><p>​    2、为什么要学数据库</p><p>​        数据是软件的灵魂/核心</p><p>​    3、做为软件开发者，我们学习数据库的哪些内容？</p><p>​        软件开发者—-数据库的使用</p><p>​            a、数据库的安装</p><p>​            b、数据库软件的操作(增、删、改、查)</p><p>​        数据库开发者—–数据库的原理及研发</p><p>数据：DATA</p><p>数据库：DATABASE</p><p>数据库管理系统：DBMS</p><p>数据库系统：DBS</p><p>数据库管理员：DBA</p><p>主键(PK)：能够唯一区分关系中的每一条记录(元祖)的一个属性</p><p>外键(FK)：表中的一个属性不是当前表的主键，却是另一张表的主键，称之为当前表的外键</p><p>展示所有数据库：show databases;</p><p>创建数据库：create database aaa;</p><p>删除数据库：drop database aaa;</p><p>选择/切换数据库：use 数据库名;</p><p>展示数据库中所有的表：show tables;</p><p>查看表结构：description/desc  表名；</p><h3 id="一、select-查"><a href="#一、select-查" class="headerlink" title="一、select   查"></a>一、select   查</h3><p>​        语法结构：select 属性名 from 表名；</p><p>​        select检索至少知道两点：</p><p>​        ①、查什么</p><p>​        ②、从哪里查</p><h4 id="1、查找一个表中的一个属性时"><a href="#1、查找一个表中的一个属性时" class="headerlink" title="1、查找一个表中的一个属性时"></a>1、查找一个表中的一个属性时</h4><p>​        select 属性名 from 表名；</p><p>​        ①、从学生表中查找学生的姓名</p><p>​            select sname from t_student;</p><p>​        ②、从系主任管理表中找出系主任的姓名</p><p>​            select mname from t_man;</p><p>​        ③、从系部管理表中找出所有系的名字</p><p>​            select dname from t_dept;</p><h4 id="2、查找一个表中的多个属性时"><a href="#2、查找一个表中的多个属性时" class="headerlink" title="2、查找一个表中的多个属性时"></a>2、查找一个表中的多个属性时</h4><p>​        select 属性1, 属性2,…  from 表名;    </p><p>​        ①、找出学生表中学生的姓名和年龄</p><p>​            select sname, sage from t_student;</p><p>​        ②、从学生表中找出学生的学号、姓名、英文名</p><p>​            select sid, sname, sename from t_student;</p><p>​        * 找出所有学生的姓名和系名   – 笛卡尔积现象，联表查询</p><p>​            select sname, dname from t_student, t_dept;</p><h4 id="3、查询一个表中的所有信息"><a href="#3、查询一个表中的所有信息" class="headerlink" title="3、查询一个表中的所有信息"></a>3、查询一个表中的所有信息</h4><p>​        select * from 表名;</p><p>​        ①、查找学生表中所有的信息</p><p>​            select * from t_student;</p><h4 id="4、查询语句–限制结果行-关键字：limit"><a href="#4、查询语句–限制结果行-关键字：limit" class="headerlink" title="4、查询语句–限制结果行   关键字：limit"></a>4、查询语句–限制结果行   关键字：limit</h4><p>​        1)、select 属性名… from 表名 limit n;</p><p>​            ①、从学生表中找出前5行学生的姓名和年龄</p><p>​                select sname, sage from t_student limit 5;</p><p>​        2)、select 属性名… from 表名 limit n, m;  从第n(从0计数)行开始，取m行</p><p>​            ①、从学生表中找出第4行到第10行的学生的所有信息</p><p>​                select * from t_student limit 3, 7;</p><p>​            ②、从学生表中找出第6行到第12行的学生的学号、姓名</p><p>​                select sid, sname from t_student limit 5, 7;</p><p>​            select sid, sname from lianxi.t_student[限定名] limit 5, 7;</p><h4 id="5、去掉重复项-关键字：distinct"><a href="#5、去掉重复项-关键字：distinct" class="headerlink" title="5、去掉重复项     关键字：distinct"></a>5、去掉重复项     关键字：distinct</h4><p>​        ①、从学生表中输出sclass，去掉重复项</p><p>​            select distinct sclass from t_student;</p><p>​        ②、从学生表中找出学生的姓名、班级编号，并去掉重复行</p><p>​            select distinct sname, sclass from t_student;    </p><h4 id="6、运用数学表达式"><a href="#6、运用数学表达式" class="headerlink" title="6、运用数学表达式"></a>6、运用数学表达式</h4><p>​        select 列名+/-/*/ /数字[列名]  from 表名;(列值必须是数值型)</p><p>​        ①、查找学生10年后的年龄</p><p>​            select sage+10 from t_student;</p><p>​            “11a”表示11， “a11“表示0；</p><p>​        ②、找出学生的学号，姓名，年龄，10年后的年龄，最终结果取前5行</p><p>​            select sid, sname, sage, sage+10 from t_student limit 5;</p><p>​        ③、输出学生表中学生的姓名，年龄加班级的和</p><p>​            select sname, sage+sclass from t_student;</p><h4 id="7、处理null值-ifnull-可能出现null的属性名-赋的值"><a href="#7、处理null值-ifnull-可能出现null的属性名-赋的值" class="headerlink" title="7、处理null值   ifnull(可能出现null的属性名,  赋的值);"></a>7、处理null值   ifnull(可能出现null的属性名,  赋的值);</h4><p>​        ①、输出学生的年龄和班级的和，如果sclass有null，则赋值0</p><p>​            select sage+ifnull(sclass,0) t_student;</p><h4 id="8、取别名-关键字：as"><a href="#8、取别名-关键字：as" class="headerlink" title="8、取别名     关键字：as"></a>8、取别名     关键字：as</h4><p>​        1)、select 属性名 as 别名 from 表名;</p><p>​            ①、给学生表中的sname取别名”姓名”，只输出前5个</p><p>​                select sname as 姓名 from t_student limit 5;</p><p>​            ②、输出学生的姓名，10年后的年龄并以此为别名</p><p>​                select sname as 姓名,  sage+10 as 10年后的年龄 from t_student;</p><p>​        2)、select 属性名  别名 from 表名;</p><p>​            ①、给学生表中的sname取别名”姓名”，只输出前5个</p><p>​                select sname 姓名 from t_student limit 5;</p><p>​            ②、输出学生的姓名，10年后的年龄并以此为别名</p><p>​                select sname 姓名,  sage+10 10年后的年龄 from t_student;</p><p>​        3)、select 属性名 as ‘别【空格】名’ from 表名;</p><p>​            ①、给学生表中的sname取别名”姓 【空格】  名”，只输出前5个</p><p>​                select sname as ‘姓    名’ from t_student;</p><p>​            String sql = “select sname as ‘姓    名’ from t_student”;</p><p>​            ②、在学生表中找出学生的学号(取别名学号)，姓名(取别名姓名)，高考分数</p><p>​        +100(取别名最终分数)，结果取第3行到第7行</p><p>​                select  sid as 学号, sname as 姓名, sscore+100 as 最终分数 from t_student</p><p>​        limit 2, 5;</p><h4 id="9、串联操作符-concat-函数"><a href="#9、串联操作符-concat-函数" class="headerlink" title="9、串联操作符    concat()函数"></a>9、串联操作符    concat()函数</h4><p>​        1)、select concat(列名, 列名) from 表名;  将两个列变为字符串拼接起来</p><p>​            ①、从学生表中找出学生的学号、姓名并拼接输出</p><p>​                select concat(sid, sname) from t_student;</p><p>​        2)、select concat(列名, ‘自己加的字符串’, 列名) from 表名; </p><p>​            ①、在学号和姓名中间加一个字符串后输出</p><p>​                select concat(sid, ‘的姓名是’, sname) from t_student;</p><p>​                select concat(sid, ‘的姓名是’, sname) as 详细信息 from t_student;</p><h4 id="10、select-now-获取当前时间"><a href="#10、select-now-获取当前时间" class="headerlink" title="10、select now();  获取当前时间"></a>10、select now();  获取当前时间</h4><p>​        ①、select now();</p><p>​        ②、select now() from t_student;</p><p>​        ③、select 3+9；</p><h4 id="11、排序-按某个属性排序，降序、升序-默认-关键字：order-by"><a href="#11、排序-按某个属性排序，降序、升序-默认-关键字：order-by" class="headerlink" title="11、排序   按某个属性排序，降序、升序(默认)   关键字：order by"></a>11、排序   按某个属性排序，降序、升序(默认)   关键字：order by</h4><p>​        1)、select  *** from 表名 order by 属性名 asc;    按属性名由低到高排列</p><p>​            ①、找出学生的姓名、高考分数，并按高考分数升序排列</p><p>​                select sname, ifnull(sscore, 0) from t_student order by sscore asc;    </p><p>​                select sname, ifnull(sscore, 0) from t_student order by sscor;</p><p>​                asc可以省略不写，因为默认升序排列</p><p>​        2)、select *** from 表名 order by 属性名 desc;  降序排列</p><p>​            ①、找出最高分学生的详细信息    </p><p>​                select * from t_student order by sscore desc limit 1;</p><p>​        注：关键字顺序，from–&gt; order by –&gt; limit</p><p>​            ②、找出学生的姓名、分数、年龄(如果为null则10岁)，班级(如果为null则1班)，</p><p>​        结果按年龄和班级升序</p><p>​                select sname, sscore, ifnull(sage, 10), ifnull(sclass, 1) from t_student order by</p><p>​            sage, sclass；</p><p>​                select sname, sscore, ifnull(sage, 10) as 年龄, ifnull(sclass, 1) as 班级 from </p><p>​            t_student order by 年龄, 班级；</p><p>​            ③、找出最小年龄学生的姓名、年龄、学号、分数*(如果年龄为null则赋20岁)</p><p>​                select sname, ifnull(sage, 20) as 年龄, sid, sscore from t_student order by 年龄             </p><p>​            limit 1; </p><h4 id="12、数据的过滤-即按照某个条件来筛选-关键字：where"><a href="#12、数据的过滤-即按照某个条件来筛选-关键字：where" class="headerlink" title="12、数据的过滤(即按照某个条件来筛选)    关键字：where"></a>12、数据的过滤(即按照某个条件来筛选)    关键字：where</h4><p>​        1)、select *** from 表名 where  筛选条件;</p><p>​            ①、找出张威的详细信息</p><p>​                select * from t_student where sname=’张威’;</p><p>​        2)、筛选条件  在  排序条件之前</p><p>​               ①、找出年龄为20岁的学生的详细信息，并按分数降序排列</p><p>​                select * from t_student where sage=20 order by sscore desc;</p><p>​        3)、如果有 &gt;、&lt; 、&gt;=、&lt;=、!=、&lt;&gt;；  where   属性名&gt;值    </p><p>​            ①、找出分数在600分以上学生的详细信息</p><p>​                select * from t_student where sscore&gt;600;</p><p>​            ②、找出分数在600以下的学生的姓名、学号、分数(如果为null则赋1分)，</p><p>​        结果按年龄降序，最终取前3</p><p>​                select sname, sid, ifnull(sscore, 1) from t_student where ifnull(sscore, 1)&lt;600 </p><p>​            order by sage desc limit 3;        </p><p>​            注：where后不能使用别名</p><p>​        4)、查找范围       where 属性名  between 值1  and  值2;</p><p>​            ①、找出年龄在18到20之间的学生的详细信息</p><p>​                select * from t_student where sage between 18 and 20；</p><p>​        5)、查找多个条件   关键字： and</p><p>​            ①、查找年龄在20岁以下，且分数在500分以上的学生的详细信息</p><p>​                select * from t_student where sage&lt;20 and sscore&gt;500;</p><p>​            ②、查找分数500分以上，年龄在18到20之间且是1班的学生的详细信息</p><p>​                select * from t_student where (sscore&gt;500) and (sage between 18 and 20) and </p><p>​            (sclass=1);</p><p>​                select * from t_student where (sscore&gt;500) and (sage&gt;=18 and sage&lt;=20) and         </p><p>​            (sclass=1);</p><p>​        6)、查找多个条件   关键字：or</p><p>​            ①、找出学生是1班的，或年龄是22岁以上，或分数500以上的所有男生的详细信息</p><p>​                select * from t_student where (sclass=1 or sage&gt;22 or sscore&gt;500) and ssex=’男’;</p><p>​            注：and 优先级高于 or</p><p>​        7)、判断查询属性为null   关键字：is        where 属性名 is null;</p><p>​            ①、找出年龄为null的学生的详细信息</p><p>​                select * from t_student where sage is null;</p><p>​        8)、查询多个相同属性值   关键字：in       where 属性名 in(值1, 值2, 值3, …);</p><p>​            ①、找出学号是1201, 1205, 1209, 1211的学生的详细信息</p><p>​                select * from t_student where sid in(1201, 1205, 1209, 1211);</p><p>​                select * from t_student where sid =1201 or sid=1205 or sid=1209 or sid=1211;</p><p>​            ②、找出英文名为Apple、Orange、Tea、Ice的学生的姓名、学号、英文名，并按年龄降</p><p>​        序</p><p>​                select sname,sage, sid, sename from t_student where sename in(‘Apple’, </p><p>​            ‘Orange’, ‘Tea’, ‘Ice’) order by sage desc；</p><p>​            ③、找出学号为1201, 1202, 1203, 1204, 1205的学生的详细信息</p><p>​                select * from t_student where sid in(1201, 1202, 1203, 1204, 1205);</p><p>​                select * from t_student where sid&gt;=1201 and sid&lt;=1205;</p><p>​        9)、当需要对条件取反时； 关键字：not       where  not 筛选条件;</p><p>​            ①、找出学号是1201, 1205, 1209, 1211之外的的学生的详细信息</p><p>​            select * from t_student where not sid in(1201, 1205, 1209, 1211);</p><p>​            select * from t_student where not (sid =1201 or sid=1205 or sid=1209 or sid=1211);</p><p>​            ②、</p><p>​                select * from t_student where not (sage&gt;18 and sscore&gt;500);</p><h4 id="13、模糊查询-关键字：like-like之后又两个符号’-’和’-’"><a href="#13、模糊查询-关键字：like-like之后又两个符号’-’和’-’" class="headerlink" title="13、模糊查询   关键字：like   like之后又两个符号’_’和’%’"></a>13、模糊查询   关键字：like   like之后又两个符号’_’和’%’</h4><p>​            1)、’_’代表一个字符   where 属性名 like ‘规则’;</p><p>​                ①、找出姓张，且名字只有两个字符的学生的详细信息</p><p>​                    select * from t_student where sname like ‘张_’;</p><p>​            2)、’%’代表n个字符(n可以为0)</p><p>​                ①、找出英文名中含有‘ee’的学生的姓名和英文名，并按班级排序</p><p>​                    select sname, sename from t_student where sename like ‘%ee%’ </p><p>​                order by sclass desc;</p><p>​                ②、找出英文名中有字母‘a’和字母’e’的学生的详细信息</p><p>​                    select * from t_student where sename like ‘%a%e%’ or sename like </p><p>​                ‘%e%a%’ order by sclass;</p><p>​            注：模糊查询一般做搜索，用来判断字符串，会把所有数据都搜索一边，称之为通</p><p>​        配符，一般能用其它操作达到目的，就不使用通配符。</p><h4 id="14、SQL正则表达式-子串匹配"><a href="#14、SQL正则表达式-子串匹配" class="headerlink" title="14、SQL正则表达式     子串匹配"></a>14、SQL正则表达式     子串匹配</h4><h4 id="where-属性名-regexp-‘正则表达式’"><a href="#where-属性名-regexp-‘正则表达式’" class="headerlink" title="where 属性名 regexp ‘正则表达式’;"></a>where 属性名 regexp ‘正则表达式’;</h4><p>​            select * from t_student where sename regexp ‘[abc]ea’;</p><p>​            1)、</p><p>​                ①、找出英文名与正则表达式’ee’匹配的学生的详细信息</p><p>​                    select * from t_student where sename regexp ‘ee’;</p><p>​                    select * from t_student where sename regexp ‘^ee$’;</p><p>​                ②、找出英文名与正则表达式’a’匹配的学生的详细信息</p><p>​                    select * from t_student where sename regexp ‘a’;</p><p>​            2)、[] 表示或，取其中之一</p><p>​                ①、找出英文名中含有a或b或c 的学生的详细信息</p><p>​                    select * from t_student where sename regexp ‘[abc]’;</p><p>​                ②、找出英文名中含有TA、Ta、tA或ta的学生的详细信息</p><p>​                    select * from t_student where sename regexp ‘[Tt][Aa]’;</p><p>​            3)、|  表示或</p><p>​                ①、找出英文名中有’ee’或‘ea’的学生的详细信息</p><p>​                    select * from t_student where sename regexp ‘ee|ea’;</p><p>​            4)、^  表示取反</p><p>​                ①、找出英文名中没有’ea’的学生的详细信息</p><p>​                    select * from t_student where sename regexp ‘[^ea]’;</p><p>​            5)、-  表示区间</p><p>​                ①、找出英文名中含有字母的学生的详细信息</p><p>​                    select * from t_student where sename regexp ‘[a-zA-Z]’;</p><p>​                ②、找出英文名中不含a或b或c的学生的详细信息</p><p>​                    select * from t_student where not sename regexp ‘[abc]’;</p><p>​            6)、\  表示转义</p><p>​                ①、找出英文名中含有 ‘.’ 的学生的详细信息</p><p>​                    select * from t_student where sename regexp ‘\.’;</p><p>​                ②、找出英文名中含有 ‘&#39; 的学生的详细信息</p><p>​                    select * from t_student where sename regexp ‘\\‘;</p><p>​                ③找出英文名中含有 ‘-‘ 的学生的详细信息</p><p>​                    select * from t_student where sename regexp ‘\-‘;</p><p>​            7)、{}  表示数量</p><p>​                ①、找出电话号码中含有3个6的学生详细信息</p><p>​                    select * from t_student where sphone regexp ‘6{3}’;</p><p>​                ②、找出电话号码中含有至少3个，最多5个6的学生详细信息</p><p>​                    select * from t_student where sphone regexp ‘6{3, 5}’;</p><p>​            8)、其它  ^   $</p><p>​                ①、找出英文名中以’A’ 开头的学生的详细信息</p><p>​                    select * from t_student where sename regexp ‘^A’;</p><p>​                ②、匹配手机号</p><p>​                    select * from t_student where sphone regexp ‘^1[35789][0-9]{9}$’;</p><h4 id="15、函数"><a href="#15、函数" class="headerlink" title="15、函数"></a>15、函数</h4><h5 id="15-1、文本处理函数"><a href="#15-1、文本处理函数" class="headerlink" title="15-1、文本处理函数"></a>15-1、文本处理函数</h5><p>​            1)、left(str, n);   表示返回字符串str左边的n的个字符</p><p>​                ①、返回所有学生的姓名、英文名和英文名左边的3个字母</p><p>​                    select sname, sename, left(sename, 3) from t_student;                    </p><p>​            2)、right(str, n); 表示返回字符串str右边的n个字符</p><p>​                ①、返回所有学生的姓名、英文名、英文名中第2个和第3个字母</p><p>​                        左边3个的右边2个</p><p>​                    select sname,sename, right(left(sename, 3), 2) from t_student;</p><p>​            3)、length(str)   表示长度</p><p>​                ①、返回所有学生的姓名、英文名、英文名的长度</p><p>​                    select sname,sename, length(sename) from t_student;</p><p>​            4)、locate(substr, str); 表示substr在str中的位置</p><p>​                ①、获取学生的英文名和字符串’ee’在英文名中的位置</p><p>​                    select sename,locate(‘ee’, sename) from t_student;</p><p>​            5)、lower(str);  转小写</p><p>​                ①、获取学生的英文名和英文名的小写</p><p>​                    select sename, lower(sename) from t_student;</p><p>​            6)、upper(str);  转大写</p><p>​                ①、获取学生的英文名和英文名的大写</p><p>​                    select sename, upper(sename) from t_student;</p><p>​            7)、Ltrim(str); 去掉左边空格</p><p>​                ①、获取学生的英文名和去掉左边空格</p><p>​                    select sename, ltrim(sename) from t_student;</p><p>​            8)、Rtrim(str); 去掉右边空格</p><p>​                ①、获取学生的英文名和去掉右边空格</p><p>​                    select sename, rtrim(sename) from t_student;</p><p>​            9)、trim(str); 去掉两边空格</p><p>​                ①、获取学生的英文名和去掉左右两边的空格</p><p>​                    select sename, trim(sename) from t_student;</p><h5 id="15-2、时间处理函数"><a href="#15-2、时间处理函数" class="headerlink" title="15-2、时间处理函数"></a>15-2、时间处理函数</h5><p>​            1)、curdate(); 返回日期的函数     select curdate();</p><p>​            2)、curtime();返回时间的函数     select curtime();</p><p>​            3)、now(); 返回当前时间    select now();</p><p>​            4)、sysdate(); 返回系统时间   select sysdate();</p><p>​            5)、UTC_DATE(); 返回国际协调时间   select UTC_DATE();</p><p>​            6)、month(bir); 返回月份</p><p>​                ①、找出学生的姓名、生日、和出生月份</p><p>​                    select sname, sbir, month(sbir) from t_student;</p><p>​            7)、monthname(bir); 返回月份的英文名</p><p>​                ①、找出学生的姓名、生日、和出生月份的英文名</p><p>​                    select sname, sbir, monthname(sbir) from t_student;</p><p>​            8)、month( now() ); 返回今天的月份    select month( now() );</p><p>​            9)、dayname( d ); 返回星期几的英文名    select dayname( now() );</p><p>​            10)、dayofweek( d ); 返回星期的第几天    select dayofweek( now() );</p><p>​            11)、weekofyear( d ); 返回今年的第几个星期    select weekofyear( now() );</p><p>​            12)、dayofyear( d ); 返回今年的第多少条    select dayofyear( now() ); </p><p>​            13)、dayofmonth( d ); 返回今天是本月的第多少天    selectdayofmonth( now() );</p><p>​            14)、date_format(日期, 格式); 按固定格式输出</p><p>​                select date_format(now(), ‘%Y年-%m月-%d日’);</p><p>​                ①、输出学生的姓名，生日，生日按格式(–月–日–年)</p><p>​                    select snema, sbir, date_format(sbir, ‘%m月-%d日-%Y年’) from         </p><p>​                t_student;</p><h4 id="16、聚集函数-汇总函数"><a href="#16、聚集函数-汇总函数" class="headerlink" title="16、聚集函数(汇总函数)"></a>16、聚集函数(汇总函数)</h4><p>​        1)、avg( d );  返回平均值</p><p>​            ①、输出平均成绩</p><p>​                select avg(sscore) from t_student;</p><p>​        2)、count(字段/属性);    返回行数</p><p>​            ①、统计有多少个学生</p><p>​                select count(sid) from t_student;</p><p>​                select count(*) from t_student;</p><p>​            ②、输出学生的个数和平均年龄</p><p>​                select count(*), avg(sage) from t_student;</p><p>​        3)、max(字段/属性);  返回最大值</p><p>​            ①、求最大年龄</p><p>​                select max(sage) from t_student;</p><p>​            ②、求最大年龄的学生的姓名</p><p>​                select sname from t_student where sage=(select max(sage) from </p><p>​            t_student);    子查询</p><p>​        4)、min(字段/属性);  返回最小值</p><p>​            ①、求最小年龄</p><p>​                select min(sage) from t_student;</p><p>​        5)、sum(字段/属性);  返回和</p><p>​            ①、求总分</p><p>​                select sum(sscore) from t_student;</p><p>​            ②、求男生的 年龄和  及平均年龄</p><p>​                select sum(sage), avg(sage) from t_student where ssex=’男’;</p><p>​            ③、统计有多少男生</p><p>​                select count(*) from t_student where ssex=’男’;</p><h4 id="17、分组-关键字：group-by"><a href="#17、分组-关键字：group-by" class="headerlink" title="17、分组    关键字：group by"></a>17、分组    关键字：group by</h4><p>​        select 聚集函数 from 表名 group by 属性1, 属性2;</p><p>​        ①、分别找出男生、女生中的最高成绩</p><p>​            select max(sscore) from t_student where ssex=’男’;</p><p>​            select max(sscore) from t_student where ssex=’女’;</p><p>​        ②、按照班级分组，求每个组的人数</p><p>​            select sclass, count(*) from t_student group by sclass;</p><p>​        ③、按性别分组，求每个组的最大年龄</p><p>​            select ssex, max(sage) from t_student group by ssex;</p><p>​        ④、按系编号分组，输出每个组的系编号和500分以上的学生的个数</p><p>​            select did, count(*) from t_student where sscore&gt;500 group by did;</p><p>​        ⑤、按系编号分组，输出每个组的系编号和500分以上的学生的个数，按系编号降序排</p><p>​        列，并取前2个</p><p>​            select did, count(*) from t_student where sscore&gt;500 group by did order </p><p>​        by did desc limit 2;</p><p>​        注：关键字的顺序</p><p>​        ⑥、按性别和班级分组，求每个组的人数，并输出组名(性别、班级)</p><p>​            select ssex, sclass, count(*) from t_student group by ssex, sclass;    </p><p>​            select sclass, ssex,  count(*) from t_student group by sclass,ssex;</p><p>​        ⑦、按性别和班级分组，求每个组的人数，并输出组名(性别、班级)，结果按人数降序排</p><p>​    列</p><p>​            select ssex, sclass, count(*) from t_student group by ssex, sclass order by</p><p>​        count(*) desc;</p><p>​        ⑧、按性别、系编号、班级分组，求每个组的人数</p><p>​            select ssex,did, sclass, count(*) from t_student group by ssex, did, sclass; </p><p>​    横向统计 ：关键字rollup</p><p>​            select ssex,did, sclass, count(*) from t_student group by rollup(ssex, did, </p><p>​        sclass); </p><h4 id="18、分组后过滤-关键字：having-放在group-by后"><a href="#18、分组后过滤-关键字：having-放在group-by后" class="headerlink" title="18、分组后过滤  关键字：having     放在group by后"></a>18、分组后过滤  关键字：having     放在group by后</h4><p>​        ⑨、按性别、系编号分组，输出人数大于5的组的编号和人数</p><p>​            select ssex, did, count(<em>)  from t_student group by ssex, did having count(</em>)&gt;5</p><h5 id="完整的关键字顺序"><a href="#完整的关键字顺序" class="headerlink" title="*完整的关键字顺序"></a>*完整的关键字顺序</h5><p>​            select distinct 属性1,…, 聚集函数 from 表名 where 筛选条件 group by 属性1,…</p><p>​        having 过滤条件 order by 属性1,… limit n, m;</p><p>​            where的条件不能使用聚集函数，having的条件可以使用聚集函数，having必须跟</p><p>​        在group by后，没有group by 就没有having；</p><p>​            ⑩、按性别、系编号将300分以上的学生分组，输出人数大于4小于8的组的性别、    </p><p>​        编号、人数，结果按系编号降序排列，最终取第1个值</p><p>​                select ssex,did, count(<em>) from t_student where sscore&gt;300 group by ssex, did having     ) &gt;4 and count(</em>)&lt;8 order by did desc limit 1;</p><h4 id="19、子查询"><a href="#19、子查询" class="headerlink" title="19、子查询"></a>19、子查询</h4><p>​    1)、select <strong>* from 表名 where *</strong> (select * from 表名 where *);</p><p>​        ①、找出跟王涛一个班的学生的详细信息</p><p>​            select sclass from t_student where sname=’王涛’;</p><p>​            select * from t_student where sclass = (select sclass from t_student where </p><p>​        sname=’王涛’);</p><p>​        ②、找出与1203或1205年龄一样大的学生的姓名和年龄</p><p>​            select sage from t_student where sid in (1203, 1205);</p><p>​            select sname, sage from t_student where sage in (select sage from t_student </p><p>​        where sid in (1203, 1205));</p><p>​        ③、找到学号为1210的学生的系名</p><p>​            select did from t_student where sid=1210;</p><p>​            select dname from t_dept where did=(select did from t_student where </p><p>​        sid=1210);</p><p>​        ④、找出刘某某的系主任名</p><p>​            select did from t_student where sname=’刘某某’;</p><p>​            select mid from t_dept where did=(</p><p>​                select did from t_student where sname=’刘某某’);</p><p>​            select mname from t_man where mid=(</p><p>​                    select mid from t_dept where did=(</p><p>​                        select did from t_student where sname=’刘某某’));</p><p>​        ⑤、找出比刘某某年龄大 且 分数比1203高的学生的详细信息</p><p>​            select * from t_student where     sage&gt;(select sage from t_student </p><p>​        where sname=’刘某某’) and sscore&gt;(select sscore fromt_student where sid=1203);</p><p>​        ⑥、找出最高分数学生的姓名、学号、分数</p><p>​            select sname, sid, sscore from t_student where sscore=(select max(sscore) </p><p>​        from t_student);</p><p>​        ⑦、统计平均分以上的学生有多少人</p><p>​            select count(*) from t_student where sscore&gt;(select avg(sscore) from </p><p>​        t_student);</p><p>​        ⑧、找出比全校平均年龄，小的每个班的平均年龄</p><p>​            select sclass, avg(sage) from t_student group by sclass having avg(sage)&lt;(select </p><p>​        avg(sage) from t_student);</p><p>​    2)、关键字：all</p><p>​        ①、找出比2班每个学生都大的学生信息</p><p>​            select * from t_student where sage&gt; all (select sage from t_student where </p><p>​        sclass=2);</p><p>​        ②、找出比500以上每个学生都大的学生的姓名</p><p>​            select sname from t_student where sage&gt; all (select sage from t_student         </p><p>​        where score&gt;500);</p><p>​    3)、关键字 ：any  只要有一个匹配</p><p>​        ①、查询年龄与Tea或Ice或Eat年龄相同的学生的姓名</p><p>​            select sname from t_student where sage = any (select sage fromt_student     </p><p>​    where sename in(‘Tea’, ‘Ice’, ‘Eat’));</p><h4 id="20、联合查询"><a href="#20、联合查询" class="headerlink" title="20、联合查询"></a>20、联合查询</h4><p>​    1)、</p><p>​    ①、查找每个学生的姓名和系名</p><p>​        select sname, dname from t_student, t_dept;  笛卡尔积现象</p><p>​        select sname, dname from t_student, t_dept where t_student.did=t_dept.did;</p><p>​    ②、查找每个学生的姓名，系编号，系名</p><p>​        select sname, t_dept.did, dname from t_student, t_dept where </p><p>​    t_student.did=t_dept.did;</p><p>​        取别名：</p><p>​        select sname, d.did, dname from t_student as s, t_dept as d where </p><p>​    s.did=d.did;</p><p>​    ③、输出学生的学号、姓名、系编号、系名、系主任编号、系主任姓名</p><p>​        select sid, sname, d.did, dname, m.mid, mname from t_student as s, t_dept as d,</p><p>​    t_man as m where s.did=d.did and d.mid=m.mid;</p><p>​        输出分数是500分以上学生的学号、姓名、系编号、系名、系主任编号、系主任姓名<br>     且按年龄降序，结果取前3个</p><p>​            select sid, sname, d.did, dname, m.mid, mname from t_student as s,</p><p>​        t_dept as d, t_man as m where s.did=d.did and d.mid=m.mid and sscore&gt;500</p><p>​        order by sage desc limit 3;</p><p>​    ④、输出最低分学生的姓名和系名</p><p>​        select sname, dname from t_student, t_dept where t_student.did=t_dept.did</p><p>​    and sscore=(select min(sscore) from t_student);</p><p>​        select sname, dname from t_student as s, t_dept as d  where s.did=d.did</p><p>​    and sscore=(select min(sscore) from s);   子查询不能使用别名</p><p>​        select sname, dname from s, t_dept where s.did=t_dept.did and sscore=(select </p><p>​    min(sscore) from t_student as s);  子查询不能使用别名</p><p>​    2)、内部联结   关键字：inner join … on  语法： 表名 inner join 表名 on 条件;</p><p>​        ⑤、在学生表和系部表中找出学生的姓名的系名(使用内联结)</p><p>​            select sname, dname from t_student inner join t_dept on </p><p>​        t_student.did=t_dept.did; </p><p>​    3)、外联结—-左联结      left outer join…on</p><p>​        ⑥、在学生表和系部表中找出学生的姓名的系名(使用左联结)</p><p>​            select sname,dname from t_student left outer join t_dept on </p><p>​        t_student.did=t_dept.did;</p><p>​    4)、外联结—-右联结      right outer join…on</p><p>​        ⑥、在学生表和系部表中找出学生的姓名的系名(使用右联结)</p><p>​            select sname,dname from t_student right outer join t_dept on </p><p>​        t_student.did=t_dept.did;</p><h3 id="二、创建表SQL"><a href="#二、创建表SQL" class="headerlink" title="二、创建表SQL"></a>二、创建表SQL</h3><p>​    关键字：create</p><p>​    语法：create table 表名(</p><p>​                字段名1  数据类型  auto_increment,  –  自动递增</p><p>​                字段名2  数据类型 not null,   –  不能为null</p><p>​                字段名3   varchar(长度),   – 设置长度</p><p>​                字段名4   数据类型  default  值,   –  设置默认值</p><p>​                ……</p><p>​                primary key(字段名1)， – 设置主键</p><p>​                foreign key(当前表中的字段名)  references 关联表(字段名【主键)</p><p>​            );</p><p>​        创建user表</p><p>​        create table user(</p><p>​            u_id int auto_increment,</p><p>​            u_username varchar(10),</p><p>​            u_password varchar(10) not null,</p><p>​            u_age int default 0,</p><p>​            primary key(u_id)</p><p>​        );</p><p>​        </p><p>​        创建books表，创建外键关联user中的u_id</p><p>​        create table books(        </p><p>​            b_id int primary key auto_increment,        </p><p>​            b_name varchar(10) not null,        </p><p>​            b_publish varchar(50),        </p><p>​            b_date date,        </p><p>​            b_price double default 0.00,        </p><p>​            u_id int,        </p><p>​            foreign key(u_id) references user(u_id)</p><p>​        );</p><h3 id="三、insert-增-添加"><a href="#三、insert-增-添加" class="headerlink" title="三、insert   增 (添加)"></a>三、insert   增 (添加)</h3><p>​    前提条件：查看表结构 </p><p>​    desc 表名;</p><p>​    1)、insert into 表名 values(值1, 值2, …);    值1，值2与数据库表中的先后顺序有关</p><p>​        insert into user values(1, ‘张三’, ‘zs123’, 18);</p><p>​        insert into user values(12, ‘李四’, ‘ls666’, 20);</p><p>​    2)、insert into 表名(字段名1, 字段名2, …) values(值1, 值2, …);  值1, 值2与前面的字段名顺序有关</p><p>​        insert into user(u_id, u_username, u_password, u_age) values(30, ‘ww’, ‘ww123’, 22);</p><p>​        insert into user(u_username, u_password) values(‘ww’, ‘ww123’);</p><p>​            主键因为有自动递增可以不写，自动递增以当前表中最大的主键值为基数递增</p><p>​    3)、一张表中的数据，添加到另一张表中(前提两张表的字段要完全一样)</p><p>​            insert into A select * from B;</p><p>​        ①、把学生表中成绩大于500且是女生的学号、姓名、电话号码(作为密码)、年龄，添加到user</p><p>​    表中</p><p>​        insert into user(u_id,u_username,u_password, u_age)  select sid, sname, sphone, sage </p><p>​    from t_student where sscore&gt;500 and ssex=’女’;</p><h3 id="四、update-修"><a href="#四、update-修" class="headerlink" title="四、update  修"></a>四、update  修</h3><p>​    1)、update 表名 set 字段名=新值 where *=值;</p><p>​        update user set u_username=’ccc’ where u_id=30;</p><p>​        update user set u_username=’ccc’, u_password=’ccc123’ where u_id=35;</p><p>​        update user set u_age = 50;   – 没有筛选条件，就会把整张表中的这个属性值全部修改掉</p><p>​        ①、把学生表中600分以上的学生性别全部改为男</p><p>​            update t_student set ssex=’男’ where sscore&gt;600;</p><p>​            select ssex from t_student where sscore&gt;600;</p><h3 id="五、delete-删"><a href="#五、delete-删" class="headerlink" title="五、delete  删"></a>五、delete  删</h3><p>​    delete from 表名 where *=值;   按某个条件删除</p><p>​    ①、删除学生表中的所有女生</p><p>​        delete from t_student where ssex=’女’;</p><h3 id="六、索引-关键字：index"><a href="#六、索引-关键字：index" class="headerlink" title="六、索引        关键字：index"></a>六、索引        关键字：index</h3><p>​    索引：是帮助Mysql高效获取数据的数据结构。</p><p>​    分类：普通索引、唯一索引、主键索引、全文索引、多列索引</p><p>​    没有索引时：</p><p>​        select * from t_student where sname=’张威’;</p><p>​        会把表中所有记录扫描一边</p><p><a href="http://blog.csdn.net/zhuxineli/article/details/14455029"><strong>explain</strong></a></p><p>explain显示了<a href="http://lib.csdn.net/base/14">mysql</a>如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="file:///C:\Users\softeem\AppData\Local\Temp\ksohtml6196\wps1.jpg" alt="img"> </p><h4 id="1、普通索引"><a href="#1、普通索引" class="headerlink" title="1、普通索引"></a>1、普通索引</h4><p>​        select * from t_student where sname=’张威’;</p><p>​        1)、创建索引</p><p>​            ①、create index 索引名 on 表名(列名);</p><p>​                给学生表中的sname创建索引</p><p>​                    create index aaa on t_student(sname);</p><p>​            ②、修改表时添加索引</p><p>​                alter table   表名  add index   索引名(列名)；    </p><p>​            ③、创建表的同时，创建索引</p><p>​                create table 表名(</p><p>​                    id int,</p><p>​                    name varchar(20) primary key,</p><p>​                    index 索引名(列名id)   – 创建索引</p><p>​                );</p><p>​        2)、展示一个表上有哪些索引</p><p>​            语法：show index from 表名;</p><p>​            ①、展示学生表上有哪些索引</p><p>​                show index from t_student;</p><p>​        3)、删除索引</p><p>​            语法：drop index 索引名 on 表名;</p><p>​            ①、删除学生表中sname上的索引aaa</p><p>​                drop index aaa on t_student;</p><h4 id="2、唯一索引"><a href="#2、唯一索引" class="headerlink" title="2、唯一索引"></a>2、唯一索引</h4><p>​        1)、创建唯一索引</p><p>​            语法：create unique index 索引名 on 表名(列名);</p><p>​            ①、给英文名创建唯一索引</p><p>​                create unique index i_unique_sename on t_student(sename);</p><p>​        2)、展示一个表上有哪些索引</p><p>​            语法：show index from 表名;</p><p>​            ①、展示学生表上有哪些索引</p><p>​                show index from t_student;</p><p>​        3)、删除索引</p><p>​            语法：drop index 索引名 on 表名;</p><p>​            ①、删除学生表中sename上的索引i_unique_sename</p><p>​                drop index i_unique_sename on t_student;</p><h4 id="3、主键索引"><a href="#3、主键索引" class="headerlink" title="3、主键索引"></a>3、主键索引</h4><p>​        主键是一种唯一性索引，但它必须指定为“PRIMARY KEY”。</p><h4 id="4、全文索引"><a href="#4、全文索引" class="headerlink" title="4、全文索引"></a>4、全文索引</h4><p>​        MySQL从3.23.23版开始支持全文索引和全文检索。在MySQL中，全文索引的索引类型</p><p>​    为FULLTEXT。全文索引可以在VARCHAR或者TEXT类型的列上创建。</p><h4 id="5、多列索引"><a href="#5、多列索引" class="headerlink" title="5、多列索引"></a>5、多列索引</h4><p>​        Create table tab(</p><pre><code>           id int,            name varchar(20),          sex char(4),</code></pre><p>​                index indexName(name,sex)</p><p>​        );</p><h3 id="七、视图-关键字：view"><a href="#七、视图-关键字：view" class="headerlink" title="七、视图       关键字：view"></a>七、视图       关键字：view</h3><p>​        一个视图就是一张虚拟的表(一般视图只查询，不做增删改)</p><p>​        1)、展示数据库上的所有视图</p><p>​            show tables;</p><p>​        2)、创建视图</p><p>​            语法：create view 视图名 as   select查询语句;</p><p>​        ①把  学生的学号、姓名、系编号、系名、系主任编号、系主任姓名  创建为一个视图</p><p>​            create view v_s_d_m as select sid,sname,d.did,dname,m.mid,mname from </p><p>​        t_student as s, t_dept as d, t_man as m where s.did=d.did and d.mid=m.mid;</p><p>​            select CONCAT(dname,”的系主任是：”, mname) from v_s_d_m;</p><p>​            ②、把500分以上的学生信息定义为一个视图</p><p>​                create view v_student_score_500 as select * from t_student where </p><p>​            sscore&gt;500;</p><p>​        3)、删除视图</p><p>​            语法：drop view 视图名;</p><p>​                drop view  v_student_score_500;</p><p>​        4)、更改视图</p><p>​            语法：create or replace 视图名 as  select查询语句;</p><p>​        注：如果来自一个表中的数据组成的视图，增删改视图里面的数据会对原表中的数据产</p><p>​        生影响；</p><p>​            如果来自多张标准中的数据组成的视图，增删改视图里面的数据不会对原表中的数</p><p>​        据产生影    响；</p><p>​            一般视图只用来查询，不要对使用进行增删改操作。    </p><h3 id="八、存储过程-关键字：procedure"><a href="#八、存储过程-关键字：procedure" class="headerlink" title="八、存储过程     关键字：procedure"></a>八、存储过程     关键字：procedure</h3><p>​     <strong>一般在大型的数据库系统中，一组为了完成特定功能的sql语句集，存储在数据库中，经过第</strong></p><p><strong>一次编译后，再次调用不需要再次编译，用户只需要指定存储过程名字并给定参数就可以执行</strong></p><p><strong>完成任务。</strong></p><p>​    0）、修改结束符号</p><p>​        delimiter #</p><p>​    1)、创建存储过程</p><p>​        语法： create procedure 存储过程名(【in/out/inout】 参数 数据类型)</p><p>​                begin</p><p>​                    sql语句1;</p><p>​                    ……</p><p>​                end</p><p>​            ①、把学生表中500分以上的学生信息、系部管理表中的所有信息、系主任管理表</p><p>​        中的所有信息  封装成一个存储过程</p><p>​            create procedure p_a()</p><p>​                begin</p><p>​                    select * from t_student where sscore&gt;500;</p><p>​                    select * from t_dept;</p><p>​                    select * from t_man;</p><p>​                end</p><p>​    2)、调用存储过程</p><p>​        语法：call 存储过程名;</p><p>​        call p_a();</p><p>​    3)、删除存储过程</p><p>​        语法：drop procedure if exists 存储过程名;</p><p>​        drop procedure if exists p_a;</p><p>​    4)、带参数的存储过程</p><p>​        create procedure tat(n1 int, n2 int)</p><p>​            begin</p><p>​                declare n3 int;</p><p>​                set n3 = n1+n2;</p><p>​                select n3 as sum;</p><p>​            end</p><p>​        create procedure tat2(n1 int, n2 int)</p><p>​            begin</p><p>​                declare n3 int;</p><p>​                if n1 is null than set n1=10;</p><p>​                end if;</p><p>​                set n3 = n1+n2;</p><p>​                select n3 as sum;</p><p>​            end</p><h5 id="带参存储过程"><a href="#带参存储过程" class="headerlink" title="带参存储过程"></a>带参存储过程</h5><p>​            分为3类4种：</p><p>​                in：表示存储过程需要给它带入一个值(默认)</p><p>​                out：表示存储过程会返回一个值</p><p>​                inout：表示存储过程即可以带入一个值，有可以带出一个值</p><p>​        I、in</p><p>​            create procedure p_c(in n1 int)</p><p>​                begin</p><p>​                    select * from t_student where sid=n1;</p><p>​                end</p><p>​            call p_c(1218);</p><p>​        II、out</p><p>​            create procedure p_d(out n2 int)</p><p>​                begin</p><p>​                    select max(sscore) into n2 from t_student;</p><p>​                end</p><p>​            call p_d(@t);   //@t：定义的全局变量，用于接受结果</p><p>​            select @t;</p><p>​        III、in–out</p><p>​            create procedure p_e(in n1 int, out n2 int)</p><p>​                begin</p><p>​                    select sscore into n2 from t_student where sid=n1;</p><p>​                end</p><p>​                call p_e(1218, @i);</p><p>​                select @i;</p><p>​        IV、inout</p><p>​            create procedure p_k(inout n1 int)</p><p>​                begin</p><p>​                    select sscore into n1 from t_student where sid=n1;</p><p>​                end</p><p>​                set @g=1218;</p><p>​                call(@g);</p><p>​                select @g;</p><p>​    5)、展示存储过程</p><p>​        ①、展示存储过程的名字</p><p>​            语法：select name from mysql.proc where db=’数据库名’;</p><p>​            select name from mysql.proc where db=’lianxi’;</p><p>​        ②、展示存储过程的详细信息</p><p>​            语法：show procedure status  where db=’数据库名’;</p><p>​            show procedure status  where db=’lianxi’;</p><h3 id="九、触发器-关键字：trigger"><a href="#九、触发器-关键字：trigger" class="headerlink" title="九、触发器    关键字：trigger"></a>九、触发器    关键字：trigger</h3><p>​        当某个增删改的sql语句执行时，会触发我们之前保存的某条sql语句</p><p>​        触发器只对表使用，不能对视图，临时表使用。</p><p>​        1、展示表上的触发器</p><p>​            语法：show triggers like ‘表名’;</p><p>​                show triggers like ‘t_student’;</p><p>​        2、删除触发器</p><p>​            语法：drop trigger 触发器名;</p><p>​                drop trigger tr_student_insert_after;</p><p>​        3、创建触发器</p><p>​            create trigger 触发器名 after/before  insert/update/delete on 被监听表 for</p><p>​        each row sql语句(增删改，没有查);</p><p>​            ①、监听insert</p><p>​            create trigger tr_student_insert_after after insert on t_student for each</p><p>​        row update t_dept set dnum=dnum+1 where did=new.did;</p><p>​            添加一个学生</p><p>​            insert into t_student(sid, sname, did) values(201911, ‘张三’, 1);</p><p>​            ②、监听delete</p><p>​            create trigger tr_student_delete_after after delete on t_student for each row</p><p>​        update t_dept set dnum=dnum-1 where did=old.did;</p><p>​            删除一个学生</p><p>​            delete from t_student where sid=201911;</p><p>​        Insert触发器</p><pre><code>           包含一张new虚拟表，这个虚拟表里面放的是刚刚插入的数据           如果使用的before，那我们可以更改insert里面的数据</code></pre><p>​        Delete触发器</p><pre><code>           包含一张old虚拟表，这个虚拟表里面放的是刚刚删除的数据</code></pre><p>​        Update触发器</p><pre><code>          包含两张表（new、old）。new表里保存的是更新数据以后的这条记录；old表里</code></pre><p>​        保存的是更新数据以前的这条记录</p><h3 id="十、E-R图"><a href="#十、E-R图" class="headerlink" title="十、E-R图"></a>十、E-R图</h3><h3 id="十一、三大范式"><a href="#十一、三大范式" class="headerlink" title="十一、三大范式"></a>十一、三大范式</h3><p>​    1、属性列不能在分</p><p>​    2、部分依赖       组合关键字</p><p>​    3、传递依赖       两个实体没有分开</p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>​    Java DataBase Connection：Java连接数据库，可以通过Java语言连接数据库，从而对数据</p><p>库(MySQL/Oracle/SQLServer…)中的数据进行增删改查操作(数据的持久化存储)</p><p>​    SQL指令(DML、DDL、存储过程、触发器、程序包、函数)</p><h3 id="一、6步"><a href="#一、6步" class="headerlink" title="一、6步"></a>一、6步</h3><p>​              (外键)</p><p>​            Connection</p><p>​            Statement</p><p>​            PreparedStatement</p><p>​            ResultSet</p><h3 id="二、调用存储过程"><a href="#二、调用存储过程" class="headerlink" title="二、调用存储过程"></a>二、调用存储过程</h3><p>​            CallableStatement</p><h3 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h3><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="D:\J1906\视频\03-JDBC\day04\笔记\05-JDBC\06-事务.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiwu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Savepoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.shiwu.utils.DBManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03_</span>事务完整 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement psta = <span class="keyword">null</span>;</span><br><span class="line">Savepoint sp = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn = DBManager.getConn();</span><br><span class="line"></span><br><span class="line"><span class="comment">//把事务默认的自动提交--改为--手动提交</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置事务的隔离级别</span></span><br><span class="line">             conn.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);</span><br><span class="line"></span><br><span class="line">String sql1 = <span class="string">&quot;update person set money=money-1000 where pname=&#x27;张三&#x27;&quot;</span>;</span><br><span class="line">String sql2 = <span class="string">&quot;update person set money=money-1000 where pname=&#x27;李四&#x27;&quot;</span>;</span><br><span class="line">String sql3 = <span class="string">&quot;pdate person set money=money-1000 where pname=&#x27;王五&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">psta = conn.prepareStatement(sql1);</span><br><span class="line">psta.executeUpdate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义回滚的位置</span></span><br><span class="line">sp = conn.setSavepoint();</span><br><span class="line"></span><br><span class="line">psta = conn.prepareStatement(sql2);</span><br><span class="line">psta.executeUpdate();</span><br><span class="line"></span><br><span class="line">psta = conn.prepareStatement(sql3);</span><br><span class="line">psta.executeUpdate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;执行成功！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行失败！&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//conn.rollback();  //回滚，一般回滚到修改(手动)提交方式的地方</span></span><br><span class="line">conn.rollback(sp);<span class="comment">//回滚到定位处 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.commit();  <span class="comment">//手动的提交事务</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">DBManager.close(conn, psta, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四、连接池"><a href="#四、连接池" class="headerlink" title="四、连接池"></a>四、连接池</h3><h4 id="1、dbcp–主打"><a href="#1、dbcp–主打" class="headerlink" title="1、dbcp–主打"></a>1、dbcp–主打</h4><h4 id="2、c3p0–了解"><a href="#2、c3p0–了解" class="headerlink" title="2、c3p0–了解"></a>2、c3p0–了解</h4><h4 id="3、阿里连接池"><a href="#3、阿里连接池" class="headerlink" title="3、阿里连接池"></a>3、阿里连接池</h4><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>​    1、html标签 (骨骼、肉体)</p><p>​        搭建页面的结构，标记性语言</p><p>​            格式标签</p><p>​            文本标签</p><p>​            超链接标签</p><p>​            图形、图像标签</p><p>​            音频、视频标签</p><p>​            分区标签</p><p>​    2、CSS样式 (衣服、化妆)</p><p>​        对html结构的装饰、描述性语言</p><p>​            选择器</p><p>​            属性、样式</p><p>​    3、JS (动态效果)</p><p>​        编程语言</p><p>​            数据类型、标识符、关键字、条件语句、循环语句、</p><p>​            函数、内置对象、BOM、DOM</p><p>​    4、jQuery框架</p><p>​            js框架、基本框架</p><p>​                选择器+效果</p><p>​    5、Bookstrap框架</p><p>​            给页面给样式或动态效果</p><p>​    6、AngularJS/VueJS</p><h3 id="web应用的构成"><a href="#web应用的构成" class="headerlink" title="web应用的构成"></a>web应用的构成</h3><h4 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C/S架构"></a>C/S架构</h4><h5 id="Client-Server：客户端-服务端模式-比如：QQ、英雄联盟"><a href="#Client-Server：客户端-服务端模式-比如：QQ、英雄联盟" class="headerlink" title="Client-Server：客户端-服务端模式(比如：QQ、英雄联盟)"></a>Client-Server：客户端-服务端模式(比如：QQ、英雄联盟)</h5><p>​        优点：体验度比较好</p><p>​        缺点：所有用户都必须下载客户端，并且在应用更新时需要更新，消耗大量网络宽带，</p><p>​            对客户端设备有一点要求</p><h4 id="B-S架构"><a href="#B-S架构" class="headerlink" title="B/S架构"></a>B/S架构</h4><h5 id="Broser-Server：浏览器-服务端模式-比如：京东、淘宝"><a href="#Broser-Server：浏览器-服务端模式-比如：京东、淘宝" class="headerlink" title="Broser-Server：浏览器-服务端模式(比如：京东、淘宝)"></a>Broser-Server：浏览器-服务端模式(比如：京东、淘宝)</h5><p>​        优点：对客户端几乎没有要求，在应用更新时不需要客户端做任何事情，只需要在客户</p><p>​                端进行渲染修改，随着css3+H5的发展，基于浏览器的应用越来越接近于原生态</p><p>​        缺点：用户体验相对不稳定，调用本机功能兼容性问题(不同的浏览器，由不同的生产厂</p><p>​                家生产，内核不一样，所以存在兼容性问题)</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>​    格式标签</p><p>​    文本标签</p><p>​    超链接标签</p><p>​    多媒体标签</p><p>​    图形图像标签</p><p>​    表格标签</p><p>​    *表单标签</p><p>​    *分区标签(div+span)</p><p>​    语义化标签</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>​    CSS属性—-背景</p><p>​    CSS属性—-边框</p><p>​    CSS属性—-文本</p><p>​    CSS布局—-盒子模型</p><p>​    CSS布局—-定位与浮动</p><p>​    CSS过渡与自定义动画</p><p>​    重叠样式表</p><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><p>​    JavaScript：是一门基于HTML的脚本语言(无法独立运行，一般嵌入到html中运行，自从有了</p><p>NodeJS之后，js可以基于node环境运行)，js是一门基于对象的语言(不是面向对象，没有类的概</p><p>念，但是有对象、有构造器)，是一门基于事件驱动(可以通过页面中的可交互控件触发js代码)的语</p><p>言。</p><p>​    由三大部分组成：</p><p>​        1、ECMAScript核心语法 (js的基本语法)</p><p>​        2、DOM模型 (Document Object Model)</p><p>​        3、BOM模型 (Browse Object Model)</p><p>Java：</p><p>​    面向对象 (任何对象都需要创建)</p><p>​    需要先编译，在运行    </p><p>​    强类型语言 (任何数据类型在使用时，都需要先声明类型，并且所有数据类型一旦定义则无法</p><p>更改)</p><p>​    四类八种数据数据类型 (引用类型)</p><p>JS：</p><p>​    基于对象 (有一系列的内置对象，同时也可以创建)</p><p>​    无需编译，可以直接运行</p><p>​    弱类型语言 (所有数据类型都不必事先声明，并且在使用期间能随时动态的改变数据类型)</p><p>​    JS的数据类型都可以通过关键字var表示：</p><p>​        数字类型number、字符串类型string、布尔类型boolean、null、undefined、NaN、</p><p>​    对象类型</p><p>​        数字类型里面都是double类型(没有整数、小数区分)</p><p>​        字符串类型里面都是字符串(没有字符类型char)</p><p>JS在页面中使用的三种方式：</p><p>​    1、在HTML页面的头部，使用<script>标签包裹js代码</p><p>​    2、在HTML页面中</body>之前，使用<script>标签包裹js代码  ---- 推荐</p><p>​    3、在外部js目录中新建js文件用于书写js代码，然后通过<script src="">标签引入到当前</p><p>HTML页面中  —- 推荐</p><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>​    JSP=HTML+Java  (Java Server Page)在服务器上运行的页面</p><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><h3 id="JSP注释："><a href="#JSP注释：" class="headerlink" title="JSP注释："></a>JSP注释：</h3><p>​            <!-- 显示注释 -->   &lt;%– 隐藏注释 –%&gt;</p><h3 id="JSP书写格式"><a href="#JSP书写格式" class="headerlink" title="JSP书写格式"></a>JSP书写格式</h3><p>​        Java片段  &lt;%    Java代码  %&gt;</p><p>​        Java声明 &lt;%!   声明静态代码块、变量、方法   %&gt;</p><p>​        Java表达式&lt;%=向页面输出的内容  %&gt;  【out.println()】</p><h3 id="JSP三大指令"><a href="#JSP三大指令" class="headerlink" title="JSP三大指令"></a>JSP三大指令</h3><h4 id="page"><a href="#page" class="headerlink" title="page"></a>page</h4><p>​            import：导包</p><p>​            pageEncoding：告诉JSP引擎要编译的文件使用的编码方式</p><p>​            contentType：服务器告诉客户端所响应的数据的数据格式</p><p>​            errorPage=”/url”：如果页面有错误，则跳转到指定资源</p><p>​                            “/“当前目录下指定的资源，绝对路径</p><p>​                            “”没有斜杠，相对路径</p><p>​            isErrorPage：是否参加throwable对象，默认false</p><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>​        静态包含 &lt;%@ include file=”page3.jsp” %&gt;</p><p>​                两个代码合并，在把两个代码合在一起编译</p><p>​        动态包含 &lt;jsp:include page=”page3.jsp”&gt;</jsp:include></p><p>​                两个代码不合并，第一段代码先编译，当执行到include时编译第二段代码</p><h4 id="taglib"><a href="#taglib" class="headerlink" title="taglib"></a>taglib</h4><p>​        引入标准标签库</p><h3 id="JSP六个动作指令"><a href="#JSP六个动作指令" class="headerlink" title="JSP六个动作指令"></a>JSP六个动作指令</h3><h4 id="动态包含：-lt-jsp-include-page-”page6-jsp”-gt"><a href="#动态包含：-lt-jsp-include-page-”page6-jsp”-gt" class="headerlink" title="动态包含：&lt;jsp:include page=”page6.jsp”&gt;"></a>动态包含：&lt;jsp:include page=”page6.jsp”&gt;</jsp:include></h4><h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><p>​    (页面间的跳转–服务器跳转forward：路径不变，页面内容变化)</p><p>​          (客户端跳转–路径、页面内容都发生变化)</p><h4 id="带参数"><a href="#带参数" class="headerlink" title="带参数"></a>带参数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;page6.jsp&quot;</span>&gt;</span><br><span class="line">&lt;jsp:param value=<span class="string">&quot;zhangsan&quot;</span> name=<span class="string">&quot;uname&quot;</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure><h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 通过无参构造函数实例化实体类 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;jsp:useBean id=<span class="string">&quot;dog&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.servlet.Dog&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;jsp:setProperty name=<span class="string">&quot;dog&quot;</span> value=<span class="string">&quot;小黑&quot;</span> property=<span class="string">&quot;dname&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;jsp:setProperty name=<span class="string">&quot;dog&quot;</span> value=<span class="string">&quot;7&quot;</span> property=<span class="string">&quot;dage&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/jsp:useBean&gt;</span><br><span class="line"></span><br><span class="line">&lt;%=dog %&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;jsp:getProperty property=<span class="string">&quot;dname&quot;</span> name=<span class="string">&quot;dog&quot;</span>/&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;jsp:getProperty property=<span class="string">&quot;dage&quot;</span> name=<span class="string">&quot;dog&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="九个内置对象"><a href="#九个内置对象" class="headerlink" title="九个内置对象"></a>九个内置对象</h3><p>​    request(HttpServletRequest)：该对象封装了1个请求，客户端的信息全部封装到</p><p>request对象中了，那么我们就可以通过调用request对象中的方法，获取到我们想要的</p><p>客户端的信息了</p><p>​    response(HttpServletResponse)：代表服务器响应客户端</p><p>​    session(HTTPSession)：代表一次会话，客户端和服务器的一次会话</p><p>一次会话：即浏览器打开到浏览器关闭(会话的开始：和服务器建立连接；会话结束：浏</p><p>览器关闭)</p><p>​    page：代表当前页面，类似于java中的this</p><p>​    config(ServletConfig)：代表配置信息</p><p>​    out(JspWriter)：服务器向页面输出内容</p><p>​    application(javax.servlet.ServletContext)：代表整个web项目</p><p>​    pageContext(javax.servlet.PageContext)：代表页面的上下文</p><p>​    exception(java.lang.Throwable)：如果设置了错误页面，则会跳转到指定的错误页</p><p>面可以通过exception.getMessage();获取错误信息</p><h4 id="每次请求服务器，服务器所做的事情："><a href="#每次请求服务器，服务器所做的事情：" class="headerlink" title="每次请求服务器，服务器所做的事情："></a>每次请求服务器，服务器所做的事情：</h4><p>​    1.启动单独的线程</p><p>​    2.使用I/O流读取用户的请求数据</p><p>​    3.从请求数据中解析参数</p><p>​    4.处理用户请求</p><p>​    5.生成响应的数据</p><p>​    6.使用I/O流响应给客户端数据</p><h4 id="四个存放值的对象访问域"><a href="#四个存放值的对象访问域" class="headerlink" title="四个存放值的对象访问域"></a>四个存放值的对象访问域</h4><p>​    application：在它中存放值，可以在整个项目过程中获取得到值</p><p>​    session：仅对一次会话有效，在同一次会话中，所有页面和servlet都可以获取值，</p><p>​            新建会话或其他浏览器就不能访问得到值了</p><p>​    request：仅对1次请求有效，如果是服务器跳转，则可以传值；如果是客户端跳</p><p>​            转，则不能传值</p><p>​            服务器跳转：地址栏不变，可以传值</p><p>​            客户端跳转：地址栏改变，不能传值</p><p>​    page：只能当前页面使用</p><p>​    application</p><p>​    config对象</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>​    servlet的生命周期</p><p>​        1、加载并开启服务</p><p>​        2、当第一次请求该servlet时，执行无参构造函数、init方法(初始化</p><p>​    参数)、doGet/doPost/Service方法；如果服务没有断开，再次请求访问    </p><p>​    该servlet，则直接执行doGet/doPost/Service;如果服务器断开，则执行</p><p>​    destroy方法表示断开服务，用于回收资源。</p><p>​            如果想要第二次请求该servlet重复以上动作</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="2019/%E7%BD%91%E7%BB%9C.html"/>
      <url>2019/%E7%BD%91%E7%BB%9C.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络概述"><a href="#网络概述" class="headerlink" title="网络概述"></a>网络概述</h2><p>分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模宏大、<br>功能强大的网络系统，从而使众多的计算机可以方便地互相传递信息，共享硬件、软件、数据信息等资源。</p><h2 id="网络通信要素"><a href="#网络通信要素" class="headerlink" title="网络通信要素"></a>网络通信要素</h2><h3 id="1-IP-amp-端口号"><a href="#1-IP-amp-端口号" class="headerlink" title="1. IP &amp; 端口号"></a>1. IP &amp; 端口号</h3><h4 id="1-1-IP"><a href="#1-1-IP" class="headerlink" title="1.1 IP"></a>1.1 IP</h4><p>网络中主机的唯一标识，通过Ip可以定位到主机位置</p><h4 id="1-2-端口号"><a href="#1-2-端口号" class="headerlink" title="1.2 端口号"></a>1.2 端口号</h4><p>用于标识当前主机上运行的进程</p><h3 id="2-网络协议"><a href="#2-网络协议" class="headerlink" title="2.网络协议"></a>2.网络协议</h3><h4 id="2-1-TCP"><a href="#2-1-TCP" class="headerlink" title="2.1 TCP"></a>2.1 TCP</h4><ul><li>使用之前需要建立TCP连接，形成传输通道</li><li>传输前采用“三次握手”方式，点对点通信，可靠性高</li><li>可进行大数据量传输</li><li>传输完毕要释放连接</li></ul><h4 id="2-2-UDP"><a href="#2-2-UDP" class="headerlink" title="2.2 UDP"></a>2.2 UDP</h4><ul><li>不需要建立连接</li><li>发送数据是以报文形式，将数据封装成数据包</li><li>发送数据时不需要去人对方是否整备好，以及接收到后也不确认，不可靠</li><li>发送完不需要释放资源，开销小，效率快</li></ul><h2 id="java中的网络"><a href="#java中的网络" class="headerlink" title="java中的网络"></a>java中的网络</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address1 = InetAddress.getByName(<span class="string">&quot;192.168.2.1&quot;</span>);</span><br><span class="line">System.out.println(address1.getHostAddress()); <span class="comment">// 获取ip</span></span><br><span class="line">System.out.println(address1.getHostName()); <span class="comment">// 获取域名</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1. 服务端"></a>1. 服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建服务端ServerSocket,指定当前服务程序的端口号，IP默认为服务端所在主机的IP</span></span><br><span class="line">server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 等待客户端的连接</span></span><br><span class="line"><span class="comment">// accept():该方法用于监听客户端的连接，若有有客户端连接就会将客户端对应的Socket返回</span></span><br><span class="line"><span class="comment">// 若没有客户端连接，那么程序就会在此处阻塞等待</span></span><br><span class="line">System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">Socket client = server.accept();</span><br><span class="line"></span><br><span class="line">InetAddress clientAddress = client.getInetAddress(); <span class="comment">// 获取客户端IP</span></span><br></pre></td></tr></table></figure><h3 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建客户端的Socket,传入服务端IP和端口号，一创建就会发起连接</span></span><br><span class="line">socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.10.146&quot;</span>, <span class="number">8888</span>);</span><br></pre></td></tr></table></figure><h2 id="URL编程"><a href="#URL编程" class="headerlink" title="URL编程"></a>URL编程</h2><h3 id="1-UDP"><a href="#1-UDP" class="headerlink" title="1.  UDP"></a>1.  UDP</h3><p> UDP编程</p><ul><li>1.DatagramSocket：UDP对应的socket</li><li>2.DatagramPacket：UDP中的数据报包类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 创建DatagramSocket对象</span></span><br><span class="line">  InetAddress ip = InetAddress.getByName(<span class="string">&quot;192.168.10.182&quot;</span>);</span><br><span class="line">  DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.创建数据报包对象</span></span><br><span class="line">  String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">byte</span>[] buf = str.getBytes();</span><br><span class="line">  DatagramPacket p = <span class="keyword">new</span> DatagramPacket(buf, <span class="number">0</span>, buf.length, ip, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 发送</span></span><br><span class="line">  ds.send(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接收者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 创建DatagramSocket对象</span></span><br><span class="line">  DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 创建数据报包对象</span></span><br><span class="line">  <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>]; <span class="comment">// 真正用来保存数据的</span></span><br><span class="line">  DatagramPacket p = <span class="keyword">new</span> DatagramPacket(buf, <span class="number">0</span>, buf.length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.接收</span></span><br><span class="line">  System.out.println(<span class="string">&quot;等待接收&quot;</span>);</span><br><span class="line">  ds.receive(p);</span><br><span class="line">  System.out.println(<span class="string">&quot;接收完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getLength():可以获取此次接收到的字节数</span></span><br><span class="line">  System.out.println(<span class="keyword">new</span> String(buf, <span class="number">0</span>, p.getLength()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-URL"><a href="#2-URL" class="headerlink" title="2. URL"></a>2. URL</h3><p>URL:统一资源定位符</p><p>示例：<a href="http://192.168.10.162:9000/UrlTest/img/girl.jpg?name=">http://192.168.10.162:9000/UrlTest/img/girl.jpg?name=</a></p><p>​              ①           ②                     ③       ④                            ⑤</p><ul><li>①：网络协议</li><li>②：IP或域名</li><li>③：端口号 </li><li>④：具体的资源路径</li><li>⑤：查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建URL对象，参数就是需要访问的具体地址</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://cdn.sensen.fun/github/img/default_bg.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(url.getHost()); <span class="comment">// 获取ip或域名</span></span><br><span class="line">System.out.println(url.getPort()); <span class="comment">// 获取端口</span></span><br><span class="line">System.out.println(url.getPath()); <span class="comment">// 获取资源路径</span></span><br><span class="line">System.out.println(url.getQuery()); <span class="comment">// 获取查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开连接，获取连接对象</span></span><br><span class="line">URLConnection connection = url.openConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从连接对象获取输入流</span></span><br><span class="line">InputStream in = connection.getInputStream();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="2019/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"/>
      <url>2019/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<p>java程序中会默认存在的三个线程</p><ul><li>main方法：主线程</li><li>GC(垃圾回收机制，回收不用的垃圾内容数据)</li><li>异常处理机制</li></ul><h2 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h2><p>创建线程的方式</p><ul><li>继承Thread类</li><li>实现Runable接口</li><li>实现CallBack接口</li><li>线程池</li></ul><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>继承Thread类，那么Talk1这个类就是一个线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Talk1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *run方法，线程体，也就是当前线程需要执行的任务</span></span><br><span class="line"><span class="comment"> *线程启动后，系统会调用run方法</span></span><br><span class="line"><span class="comment"> * @see java.lang.Thread#run()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 获取线程的名字</span></span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">System.out.println(getName());</span><br><span class="line">System.out.println(<span class="string">&quot;小红，我好喜欢你&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 让当前线程睡眠指定时间，单位为毫秒</span></span><br><span class="line">sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 怎么使用线程？</span></span><br><span class="line"><span class="comment">// 1.创建线程对象</span></span><br><span class="line">Talk1 t1 = <span class="keyword">new</span> Talk1();</span><br><span class="line">Talk2 t2 = <span class="keyword">new</span> Talk2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.启动线程，start()表示启动当前线程</span></span><br><span class="line"><span class="comment">// 启动两个线程，这两个线程都在同时运行着</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><h3 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义类实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  <span class="comment">// 2.重写run方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:这是一个线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><p>Callable里面有个call方法，该方法是有返回值的,也就代表线程执行完后会有返回值</p><p>需要借助FutureTask类，可以获取返回值</p><ul><li>创建类型实现Callable接口，并指定返回值类型</li><li>重写call方法，线程最终调用的方法，类似run方法</li><li>创建callable的实现类对象</li><li>创建FutureTask对象，同时指定泛型，与接口一致</li><li>创建线程对象，将FutureTask对象传入，启动线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//  重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建实现类对象</span></span><br><span class="line">        Test06 t1 = <span class="keyword">new</span> Test06();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建服务</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交</span></span><br><span class="line">        Future&lt;Boolean&gt; f1 = executorService.submit(t1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        <span class="keyword">boolean</span> rs1 = f1.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭服务</span></span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h3><ul><li>1.start()启动线程</li><li>2.sleep()</li><li>3.getName()</li><li>4.setName()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置线程的名字</span></span><br><span class="line">t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程的优先级，里面参数 1-10</span></span><br><span class="line"><span class="comment">//t1.setPriority(newPriority);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main方法里面</span></span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h2><p>线程中是有一个标志位，这个标志位可以进行设置，表示当前线程是否处于中断</p><p>线程的中断 </p><ul><li>条件中断 </li><li>异常中断 </li><li>stop():暴力中断，不使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前线程中断标志位的状态</span></span><br><span class="line"><span class="comment">// true:表示是中断，false：表示不是</span></span><br><span class="line">System.out.println(isInterrupted());</span><br></pre></td></tr></table></figure><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2020/08/image-20200808234336936.png" alt="image-20200808234336936"></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setPriority(int newPriority)</td><td>更改线程的优先级</td></tr><tr><td>static void sleep(long millis)</td><td>在指定的毫秒数内让当前正在执行的线程休眠</td></tr><tr><td>void join()</td><td>等待该线程终止</td></tr><tr><td>static void yield()</td><td>暂停当前正在执行的线程对象，并执行其他线程</td></tr><tr><td>void interrupt()</td><td>中断线程，不要用这个方式</td></tr><tr><td>boolean isAlive()</td><td>测试线程是否处于活动状态</td></tr></tbody></table><h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><p>解决线程资源竞争的问题</p><ul><li><p>synchronized</p><ul><li><p>可以修饰代码块（同步代码快）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（同步监视器）&#123;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同步监视器</li><li>1.可以理解成锁。并且任何对象都可以充当锁</li><li>2.只有拿到锁的线程才能操作同步代码块中的代码，其他线程只能等待，等锁释放后线程再去抢这把锁<ul><li>与共享变量操作相关的代码都放在同步代码块中，放进去之后，其他没有拿到锁的线程就没办法接触到这个共享变量，也就不会出现多个线程操作某个共享变量</li></ul></li></ul></li><li><p>可以修饰方法（同步方法）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在方法声明中加上synchronized，这样一来整个方法将会被同步，也就是只有拿到锁的线程才能执行该方法，其他线程甚至无法进入该方法</li><li>同步方法上的锁默认就是当前方法所在类的对象</li></ul></li></ul></li><li><p>Lock：JDK5.0中添加的</p><ul><li>上锁和解锁<ul><li>Lock是一个接口，主要使用他的实现类ReentrantLock类来操作</li></ul></li></ul></li><li><p>两者区别：</p><ul><li><p>synchronized相当于自动加锁解锁</p></li><li><p>Lock需要自己手动的加锁和解锁，但是他更加灵活</p></li></ul></li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 与共享变量操作相关的代码都放在同步代码块中</span></span><br><span class="line">  <span class="comment">// 放进去之后，其他没有拿到锁的线程就没办法接触到这个共享变量，也就不会出现多个线程操作某个共享变量</span></span><br><span class="line">  <span class="keyword">if</span> (ticket.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售票成功，票号：&quot;</span> + ticket.count);</span><br><span class="line">    ticket.count--; <span class="comment">// 票的数目减1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">10</span>); <span class="comment">// 模拟卖票的耗时</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 使用ReentrantLock加锁时，一般放在try代码块中</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在执行操作共享变量的位置之前上锁</span></span><br><span class="line">    <span class="comment">// 上锁后其他线程也是无法执行的，上锁后面的代码只能被当前线程执行</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">if</span>(ticket.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售票成功，票号：&quot;</span> + ticket.count);</span><br><span class="line">      ticket.count--; <span class="comment">// 票的数目减1</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>); <span class="comment">// 模拟卖票的耗时</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>线程间通信：</p><ul><li><p>以下方法必须放在syncrhonized里面，否则包参数异常！</p></li><li><p>wait() : 可以让当前线程暂停，暂停之后释放锁，其他线  程可以获取这个锁，等待其他线程唤醒</p></li><li><p>notify():唤醒某个暂停的线程</p></li><li><p>notifyAll():唤醒所有等待的线程</p><p>​</p><p>sleep()与wait()的区别？</p><p>他们两个都能让线程进行暂停<br>sleep()不会释放当前线程占用的锁<br>wait()会释放锁</p></li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建包含5个线程的线程池对象</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Print p = <span class="keyword">new</span> Print();</span><br><span class="line"><span class="comment">// execute():添加线程执行任务，执行线程（背后就是挑一个空闲的线程去执行）</span></span><br><span class="line"></span><br><span class="line">threadPool.execute(p);</span><br><span class="line">threadPool.execute(p);</span><br><span class="line">threadPool.execute(p);</span><br><span class="line">threadPool.execute(p);</span><br><span class="line">threadPool.execute(p);</span><br><span class="line">threadPool.execute(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池不用了关掉</span></span><br><span class="line">threadPool.shutdown();</span><br></pre></td></tr></table></figure><p><strong>阿里Java开发手册禁止使用Executors创建线程池：</strong></p><blockquote><ol start="8"><li>【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式<strong>让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</strong></li></ol><p>说明：Executors各个方法的弊端：</p><p>1）  newFixedThreadPool和newSingleThreadExecutor: 主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</p><p>2）  newCachedThreadPool和newScheduledThreadPool: 主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p><ol start="9"><li>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置线程名字</span></span><br><span class="line">        ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;thread&quot;</span>).build();</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService service = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10L</span>, TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(),threadFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行线程</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="2019/%E6%B3%9B%E5%9E%8B.html"/>
      <url>2019/%E6%B3%9B%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<p>泛型：类型的参数化。就是定义类、接口时，可以将要使用到的某个数据类型定义成一个参数，在真正使用类或接口时再去确定</p><ul><li>如果泛型类使用么有指定的类型，那么泛型将为Object类型</li><li>实现泛型接口，并且确定泛型的类型，这样这个类就不是泛型类</li><li>定义一个子类继承泛型接口或者泛型类时，泛型的类型依旧不能确定，那么就得在子类上再次定义泛型，表示在使用子类时去明确泛型的类型，这样子类就是泛型类</li><li>泛型类、接口，泛型的个数可以有多个，用逗号隔开</li><li>泛型方法</li><li>注意：不能创建泛型数组，T[] t = new T[5]; 编译不通过</li></ul><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类，尖括号中是一个类型的参数，在使用类时再明确具体的类型</p><p>泛型类中可以使用这个类型的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">// 给属性声明为T类型</span></span><br><span class="line">T x;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(String name,<span class="keyword">int</span> age,T x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是泛型方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是泛型方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型方法中的泛型跟当前类没有任何关系</span></span><br><span class="line"><span class="comment">// 泛型参数E不跟类有任何关系</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">func</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 泛型接口，泛型的个数可以有多个，用逗号隔开</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span>&lt;<span class="title">T</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(T t,V v)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实现泛型接口，并且确定泛型的类型，这样这个类就不是泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">implements</span> <span class="title">MyInterface</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(String t, Integer v)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Data&lt;Integer&gt; d1 = <span class="keyword">new</span> Data&lt;Integer&gt;(<span class="string">&quot;abc&quot;</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">d1.setX(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型方法的使用</span></span><br><span class="line"><span class="comment">// 传入的参数是什么类型，那么方法中的泛型即为这个类型</span></span><br><span class="line">Integer res =  d1.func(<span class="number">100</span>);</span><br><span class="line">String res2 = d1.func(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果泛型类使用么有指定的类型，那么泛型将为Object类型</span></span><br><span class="line">Data d2 = <span class="keyword">new</span> Data(<span class="string">&quot;aaa&quot;</span>, <span class="number">20</span>, <span class="number">2</span>);</span><br><span class="line">d2.setX(<span class="string">&quot;object&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>有的时候想定义一个方法，里面的参数是一个集合对象，但是集合的泛型又不太确定</p><p>?:代表泛型的通配符，参数链表中的泛型将可以为任意的</p><p>通配符范围的限定： </p><ul><li>? extends X:泛型必须是X本身或者其子类</li><li>? super X:泛型必须是本身或者X的父类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前这种情况只能添加null</span></span><br><span class="line">  <span class="comment">// list.add(&quot;abc&quot;);</span></span><br><span class="line">  <span class="comment">// list.add(100);</span></span><br><span class="line">  <span class="comment">// list.add(new Object());</span></span><br><span class="line">  <span class="comment">// list.add(null);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取数据是可以的</span></span><br><span class="line">  Object data = list.get(<span class="number">0</span>);</span><br><span class="line">  System.out.println(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="2019/%E9%9B%86%E5%90%88.html"/>
      <url>2019/%E9%9B%86%E5%90%88.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java的集合框架："><a href="#Java的集合框架：" class="headerlink" title="Java的集合框架："></a>Java的集合框架：</h2><ul><li><p>Collection接口：</p><ul><li><p>List：里面存放的数据是有序的，并且数据是可重复的</p><ul><li>ArrayList：动态数组，顺序存储，遍历、添加（添加到末尾，非插入）效率较高<ul><li>LinkedList：链式结构，插入、删除效率高，遍历查找效率低</li><li>Vector：动态数组，比较老的集合结构，一般很少使用</li></ul></li></ul></li><li><p>Set：里面的数据是无序的，不可重复的</p><ul><li><p>HashSet：主要的实现类,无序不代表随机</p><ul><li><p>LinkedHashSet : 是在原有的基础上底层通过一个链表进行维护，遍历效率会有提升</p><p>​    若经常对set进行遍历操作，可以采用LinkedHashSet</p></li><li><p>TreeSet：TreeSet中存放的数据可以进行排序（Comparable Comparator）</p><p>​            TreeSet中存放的对象必须实现Comparable</p><p>​            TreeSet中是不能存放空对象的 ！！！</p></li></ul></li></ul></li></ul></li><li><p>Map接口：Map中存放的数据都是一对一对的，里面有一个叫做key，另外一个叫做value，键值对</p><ul><li>HashMap：主要实现类，map中数据也是无序的，线程不安全，但是效率高<ul><li>TreeMap：可以排序的</li><li>HashTable：比较老的一个，很少用,线程安全的，但是效率较低<ul><li>Properties类    property（属性）</li></ul></li></ul></li></ul></li></ul><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/10/09/jihe.png"></p><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加，添加的元素只能是指定类型的数据</span></span><br><span class="line">coll.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回集合中元素的个数</span></span><br><span class="line"><span class="keyword">int</span> num = coll.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个集合中的数据添加进去</span></span><br><span class="line">coll.addAll(coll2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除集合中数据</span></span><br><span class="line">coll2.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否包含指定元素</span></span><br><span class="line"><span class="keyword">boolean</span> bl = coll.contains(<span class="string">&quot;aq&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个集合中的元素是否相等</span></span><br><span class="line">System.out.println(coll2.equals(coll3));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断集合是否为空</span></span><br><span class="line">System.out.println(coll.isEmpty());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素</span></span><br><span class="line">coll.remove(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前集合中删除传入集合中包含的元素</span></span><br><span class="line">coll.removeAll(coll2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保留当前集合中两个集合的公共部分</span></span><br><span class="line">coll.retainAll(coll2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将集合中元素转换到数组中，括号中数组的类型即为元素类型，长度即为集合的元素的个数</span></span><br><span class="line">String[] arr = coll.toArray(<span class="keyword">new</span> String[coll.size()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合中存储的是对象时，若想判断是否相等，则必须在对象的类中重写equals()方法</span></span><br><span class="line">System.out.println(coll1.equals(coll2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前集合的迭代器对象(管家)</span></span><br><span class="line">Iterator&lt;String&gt; iterator = coll.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个方法结合使用</span></span><br><span class="line"><span class="comment">// hasNext():判断后面是否还有元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">  <span class="comment">// next():返回下一个元素</span></span><br><span class="line">  System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历过程中把某个元素删除</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  String str = iterator.next();</span><br><span class="line">  <span class="keyword">if</span> (str.equals(<span class="string">&quot;jack&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 通过迭代器对象删除</span></span><br><span class="line">    <span class="comment">// 删除要在next()方法之后执行，next之后删除不能多次执行</span></span><br><span class="line">    iterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList:动态数组，底层是由数组实现数据存储的</p><p>对于数据基本操作：</p><ul><li>增：add()</li><li>删：remove(object) remove(index)</li><li>改：set(index,element)</li><li>查：get(index)</li><li>插入：add(index,element)</li><li>遍历：迭代器（next()、hasNext()）、for、foreach</li></ul><p>新增的：</p><ul><li>add(index,element)</li><li>remove(index)</li><li>set(index,element)</li><li>get(index)</li><li>subList(startIndex,endIndex)</li><li>indexOf(object)</li><li>sort(Comparator) // 排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList对象</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置添加数据，下标不能越界</span></span><br><span class="line">list.add(<span class="number">0</span>, <span class="string">&quot;爷爷&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置的元素</span></span><br><span class="line">System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定位置的数据进行更新，参数（下标，新的值）</span></span><br><span class="line">list.set(<span class="number">4</span>, <span class="string">&quot;盖伦&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对应数据在Arraylist中的下标，若没有返回-1</span></span><br><span class="line">System.out.println(list.indexOf(<span class="string">&quot;大娃&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定位置的元素，并且会将该元素返回</span></span><br><span class="line">list.remove(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取集合中指定范围(0&lt;= x &lt; 2)元素，并以List形式返回，</span></span><br><span class="line">List&lt;String&gt; data = list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将集合中的元素拼接成字符串返回</span></span><br><span class="line">System.out.println(list.toString());</span><br></pre></td></tr></table></figure><p>ArrayList遍历方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、迭代器</span></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">  System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">  System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、foreach(依赖于迭代器)</span></span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：遍历时要删除元素，采用迭代器形式，不要用foreach会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、迭代器(可以的)</span></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">  String name = iterator.next();</span><br><span class="line">  <span class="keyword">if</span>(name.equals(<span class="string">&quot;三娃&quot;</span>)) &#123;</span><br><span class="line">    iterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对集合中元素进行排序，需要传入一个Comparator接口的对象</span></span><br><span class="line">list.sort(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line"><span class="comment">// 返回值： 小于0，o1&lt;o2 ; 等于0，o1=o2 ;大于0，o1 &gt; o2</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;compare&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList里面的常规增删改查方法与ArrayList一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;李白&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">vector.add(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h4><p>1.ArrayList</p><ul><li>创建ArrayList时，内部会生成一个空数组</li><li>第一次添加时，数组长度为10</li><li>后期数组满了后在扩容时，是扩容1.5倍</li><li>线程不安全，效率高</li></ul><p>2.Vector</p><ul><li>创建时立马生成长度为10的数组</li><li>扩容时默认以2倍扩容</li><li>线程安全，但是带来副作用就是效率低</li></ul><p>3.LinkedList</p><ul><li>链式存储结构，双链表</li></ul><ul><li>通过Node类表示数据结点，<ul><li>里面item属性用来保存具体的数据<br> undefinednext属性保存下一个结点地址<br>  undefinedprev属性保存上一个结点地址</li></ul></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>Set底层由数组+链表实现</p><ul><li>1.数据存放在数组中（数组的初始容量为16）</li><li>2.无序性是根据存放对象的哈希值经过某个算法（散列算法）算出在数组中存放的位置，从而导致存放的数据不太可能连着存放，展现出来一种无序状态</li><li>3.数据的不可重复需要：数据对象对hashcode().eauals()进行重写才能体现，否则还是可以添加重复的数据，经过hashcode()得到的哈希值算出存储的位置后：<ul><li>若数组当前位置没有数据，就直接放进去<ul><li>若数组当前位置有数据，就通过对象的equals()进行判断，</li><li>若相等则不添加，</li><li>若不相等，则以链表的形式拼接在原有数据下面；</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line">set.add(<span class="string">&quot;hack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同数据不会添加成功</span></span><br><span class="line">set.add(<span class="string">&quot;hack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet可以添加null</span></span><br><span class="line">set.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set数据的获取只能通过迭代器</span></span><br><span class="line">Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合的构造方法中可以传入另外一个Collection接口对象</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(list);</span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再把set转换成ArrayList</span></span><br><span class="line">ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet中是不能存放空对象的 ！！！</span></span><br><span class="line">set.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定规则去排序、传入Comparator对象</span></span><br><span class="line">TreeSet&lt;User&gt; set2 = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User o1, User o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>###HashMap原理简要认识：</p><ul><li>HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</li><li><ol><li>底层由 数组+链表+红黑树</li></ol></li><li><ol start="2"><li>创建HashMap时，内部存放键值对数据的数组table，没有初始化，只是初始化了一个加载因子为0.75</li></ol><ul><li>加载因子：可以认为数组中元素个数达到当前数组长度的百分比后进行扩容一个参数</li></ul></li><li><ol start="3"><li>当第一次添加数据时，会把table这个数组初始化，长度为16  </li></ol></li><li><ol start="4"><li>后续再去添加元素时，如果数组中元素的个数 = 数组长度*加载因子，那么就会进行扩容，扩容为原来的2倍</li></ol></li><li><ol start="5"><li>当数组长度大于64，并且数组中某个元素对应的链表长度大于8时，就会采用红黑树（二叉树）进行存储，提高查找的效率</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*增：put(key,value) </span></span><br><span class="line"><span class="comment">* 查：get(key)、containsKey(...)、containsValue(...)</span></span><br><span class="line"><span class="comment">* 删除：remove(key) </span></span><br><span class="line"><span class="comment">* 改：put(key,value) </span></span><br><span class="line"><span class="comment">* 长度：size() </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个指定key的类型，第二个指定value的类型</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据，注意key和value的类型</span></span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个数据</span></span><br><span class="line">System.out.println(map.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除map中的数据</span></span><br><span class="line">map.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊情况</span></span><br><span class="line"><span class="comment">// map中的key或者value都可以为null</span></span><br><span class="line">map.put(<span class="keyword">null</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定的key对应的数据</span></span><br><span class="line">map.remove(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查map中是否包含指定的key 、value</span></span><br><span class="line">System.out.println(map.containsKey(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(map.containsValue(<span class="string">&quot;jack&quot;</span>));</span><br></pre></td></tr></table></figure><p>map的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：获取key的set集合，然后遍历该集合获取map中的所有数据</span></span><br><span class="line"><span class="comment">// 返回一个包含key的set集合</span></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">Iterator&lt;String&gt; iterator1 = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">  String key = iterator1.next();</span><br><span class="line">  String value = map.get(key);</span><br><span class="line"></span><br><span class="line">  System.out.println(key + <span class="string">&quot; &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式2：</span></span><br><span class="line"><span class="comment">// values():反回一个包含所有value数据的集合</span></span><br><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line">Iterator&lt;String&gt; iterator2 = values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">  System.out.println(iterator2.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式3：</span></span><br><span class="line"><span class="comment">// entrySet():返回的是一个包含Entry对象的set集合</span></span><br><span class="line"><span class="comment">// Entry（1.8中叫Node）：就是表示key-value键值对的类</span></span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; iterator3 = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator3.hasNext()) &#123;</span><br><span class="line">  <span class="comment">// 获取键值对对象</span></span><br><span class="line">  Entry&lt;String, String&gt; entry = iterator3.next();</span><br><span class="line">  <span class="comment">// 获取key和value</span></span><br><span class="line">  String key = entry.getKey();</span><br><span class="line">  String value = entry.getValue();</span><br><span class="line"></span><br><span class="line">  System.out.println(key + <span class="string">&quot; &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CurrentHashMap"><a href="#CurrentHashMap" class="headerlink" title="CurrentHashMap"></a>CurrentHashMap</h3><blockquote><p>由于HashMap是线程不同步的，虽然处理数据的效率高，但是在多线程的情况下存在着安全问题，因此设计了CurrentHashMap来解决多线程安全问题。</p><p>JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本.</p><p><a href="https://www.jianshu.com/p/a7767e6ff2a2">https://www.jianshu.com/p/a7767e6ff2a2</a></p><p><a href="https://www.jianshu.com/p/a7767e6ff2a2">HashMap和ConcurrentHashMap的知识总结</a></p></blockquote><p><a href="https://www.jianshu.com/p/a7767e6ff2a2">HashMap和ConcurrentHashMap的知识总结</a></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap中是按照key进行一个自然排序，要求key所对应的数据必须实现Comparable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Hero, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"><span class="comment">// key不实现Comparable接口就报错</span></span><br><span class="line"><span class="comment">// treeMap.put(new Hero(&quot;jack&quot;, 200, &quot;学生&quot;), &quot;abc&quot;);</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过在构造方法中传入Comparator对象自定义比较规则，</span></span><br><span class="line"><span class="comment">// 那么key所对应的对象可以不用实现Comparable接口，即便实现了也不会生效</span></span><br><span class="line">TreeMap&lt;Hero, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Hero&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Hero o1, Hero o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.blood - o2.blood; <span class="comment">// 按照血量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>Properties:可以用来读取（加载）项目中的配置文件（例如：数据库的连接信息，用户名 密码 …）</p><p>创建配置文件（xxx.properties）:右键单击项目名 -&gt; new -&gt; file</p><ul><li>井号代表注释</li><li>内容格式：属性名=属性值 / 属性名:属性值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Properties对象</span></span><br><span class="line">Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取（加载）配置文件的数据</span></span><br><span class="line"><span class="comment">// 参数是一个输入流对象</span></span><br><span class="line"><span class="comment">// 文件是在当前项目的根路径下面，</span></span><br><span class="line"><span class="comment">// 创建输入流时，如果参数是文件的地址，默认情况下是在当前项目根路径下进行查找</span></span><br><span class="line">p.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;db.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载外部配置文件</span></span><br><span class="line"><span class="comment">// File file = new File(&quot;d:\\db.properties&quot;);</span></span><br><span class="line"><span class="comment">// p.load(new FileInputStream(file));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载之后根据属性名获取属性值</span></span><br><span class="line">String name = (String) p.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">String pwd = (String) p.get(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">String url = (String) p.get(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(name);</span><br><span class="line">System.out.println(pwd);</span><br><span class="line">System.out.println(url);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/11/04/%E9%9B%86%E5%90%88.png"></p><p><strong>1、Collection 和 Collections</strong></p><p>​        Collection是一个接口，是所有单值集合的父接口；</p><p>​        Collections是一个帮助类，这个类中提供了很多对于集合操作的静态方法</p><p><strong>2、List接口 和 Set接口的区别</strong></p><p>​        List接口和set接口都是Collection接口的子接口</p><p>​        List接口中的元素是有序可重复的；</p><p>​        Set接口中的元素是无序不可重复的；</p><p><strong>3、ArrayList 和 LinkedList的区别</strong></p><p>​        ArrayList和LinkedList集合都是List接口的实现类，其元素都是有序可重复的；</p><p>​        ArrayList中元素的存储是基于数组的实现，元素查询、添加速度比较快，插入元素速度较慢；</p><p>​        LinkedList中的元素是基于链表的实现，元素的插入速度较快；</p><p><strong>4、ArrayList 和 Verctor的区别</strong></p><p>​        ArrayList和Verctor都是基于数组的实现；</p><p>​        ArrayList是线程非安全的，但是ArrayList的存储效率比较高；</p><p>​        Verctor是线程安全的；</p><p><strong>5、HashSet和TreeSet的区别</strong></p><p>​        两者都是Set接口的实现类，其元素都是无序不可重复的；</p><p>​        区别是存储方式不同：</p><p>​            HashSet是基于hash码散列存储</p><p>​            TreeSet是树形存储</p><p><strong>6、HashMap和HashTable的区别</strong></p><p>​        两者都是基于Map接口的实现类，都表示键值对集合。</p><p>​        HashMap中运行一个null键和多个null值；但Hashtable中不允许使用null作为key和value；</p><p>​        HashMap未实现同步，是线程非安全的；Hashtable实现了同步是线程安全的；</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO</title>
      <link href="2019/IO.html"/>
      <url>2019/IO.html</url>
      
        <content type="html"><![CDATA[<p>对于数据的读写操作时，有不同的输入输出对象，Java中是将其当做流的形式来看待。</p><p>流(stream)的理解，Stream是从起源（source)到接收(sink)的有序数据</p><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><ul><li>数据的输入输出（数据的流向，以程序为中心看待）<ul><li>输入流</li><li>输出流  </li></ul></li><li>按照操作数据的单位<ul><li>字节流：每次读写数据是以一个字节为单位</li><li>字符流：每次读写数据是以一个字符（2个字节）为单位</li></ul></li><li>节点流、处理流<ul><li>节点流：就是直接建立的一种流，没有任何包装的</li><li>处理流：在节点流基础上进行包装后的流</li></ul></li></ul><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/10/06/1.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/10/06/2.png"></p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>输入：FileInputStream<br>输出：FileOutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">从该输入流读取一个字节的数据,返回-1表示读完了。  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> </span></span><br><span class="line"><span class="function">从该输入流读取最多 b.length个字节的数据为字节数组,返回读取的字节个数,返回-1表示读完了。 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> </span></span><br><span class="line"><span class="function">将 b.length个字节从指定的字节数组写入此文件输出流。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function">将 len字节从位于偏移量 off的指定字节数组写入此文件输出流。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function">将指定的字节写入此文件输出流。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">关闭此输入流并释放与流相关联的任何系统资源。  </span></span><br></pre></td></tr></table></figure><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>输入：FileReader<br>输出：FileWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">读一个字符,返回-1表示读完了。  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> </span></span><br><span class="line"><span class="function">将字符读入数组，返回读取到的字符个数,返回-1表示读完了。 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">close</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">关闭流，先刷新。 </span></span><br><span class="line"><span class="function"><span class="title">flush</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">刷新流。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> </span></span><br><span class="line"><span class="function">写入一个字符数组。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function">写入字符数组的一部分。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> </span></span><br><span class="line"><span class="function">写一个字符  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> </span></span><br><span class="line"><span class="function">写一个字符串 </span></span><br></pre></td></tr></table></figure><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>缓冲流：可以提高读写的效率<br>字节缓冲：BufferedInputStream、BufferedOutputStream<br>字符缓冲：BufferedReader、BufferedWriter</p><p>新增方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String readLine();</span><br><span class="line">一次读一行(不包含换行符)，返回读到的数据，读完了返回null。</span><br></pre></td></tr></table></figure><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>转换流：可以将字节流转换成字符流<br>输入：InputStreamReader<br>输出：OutputStreamWriter</p><p>构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader(InputStream in) </span><br><span class="line">创建一个使用默认字符集的InputStreamReader。  </span><br><span class="line">InputStreamReader(InputStream in, Charset cs) </span><br><span class="line">创建一个使用给定字符集的InputStreamReader。  </span><br><span class="line"></span><br><span class="line">OutputStreamWriter(OutputStream out) </span><br><span class="line">创建一个使用默认字符编码的OutputStreamWriter。  </span><br><span class="line">OutputStreamWriter(OutputStream out, Charset cs) </span><br><span class="line">创建一个使用给定字符集的OutputStreamWriter。 </span><br></pre></td></tr></table></figure><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>打印流：（只有输出）<br>字节：PrintStream<br>字符：PrintWriter</p><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>对象流：可以将java对象进行读写操作,使用对象流可以将数据保存文件、数据库、写入网络在网络上传输<br>输入：ObjectInputStream<br>输出：ObjectOutputStream</p><p>1、需要类实现Serializable接口，表示当前类可序列化，序列化后对象才可进行读写操作</p><ul><li>序列化机制：将一个对象（数据）转换成一个跟平台无关的二进制数据</li></ul><ul><li>序列化:将对象转换成二进制数据</li><li>反序列化:将对象的二进制数据再转成对象</li></ul><p>2、serialVersionUID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">serialVersionUID：当前这个类进行序列化时的一个序列化版本编号（全局唯一）</span><br><span class="line">可以解决一个版本兼容的问题：原先将一个对象存储后，在后面版本中类的结构有发生变化，</span><br><span class="line">这个时候可以通过serialVersionUID进行识别，确保读取时还能够读出来</span><br><span class="line"></span><br><span class="line">如果不加：那系统会自动生成一个，若后期类的结构又发生变化，那么又会重新生成，导致读取时两个serialVersionUID不一致，报错</span><br></pre></td></tr></table></figure><p>3、序列化其他注意点：</p><ul><li>transient:可以让属性值不被序列化</li><li>static:修饰的属性也不会序列化</li></ul><h2 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h2><p>随机访问流：（读写集合在一起，通过指定的模式来确定读写权限）<br>RandomAccessFile</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：file对象，参数2：指定当前流对象的模式</span></span><br><span class="line"><span class="comment">// 模式：&quot;r&quot;:表示只读；&quot;rw&quot;:表示读写</span></span><br><span class="line">RandomAccessFile(File file, String mode)</span><br></pre></td></tr></table></figure><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">特殊的方法：</span><br><span class="line"><span class="comment">// 获取指针的位置</span></span><br><span class="line"><span class="comment">// 指针的作用，指针指向流的某个位置时，那么读写操作将会从这个位置开始</span></span><br><span class="line"><span class="keyword">long</span> index = raf.getFilePointer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以手动指定指针的位置,参数：表示偏移量，在当前位置上偏移多少个字节</span></span><br><span class="line">raf.seek(<span class="number">5</span>); <span class="comment">// 偏移的最大限度可以通过file.length()间接得到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line">WriteXXX()，readXXX(),进行读写操作时，读写的数据的长度为当前数据类型的长度</span><br><span class="line">例如：   </span><br><span class="line">writeInt():写入数据将一次性写入<span class="number">4</span>个字节</span><br><span class="line">readInt():读数据时一次性读<span class="number">4</span>个字节</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/10/06/3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
      <url>2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<p>正则表达式是一种最早起源于Perl语言的特殊字符串技术，可以通过一些固定的模式编写一些特殊的字符串，通过对这些特殊字符串使用，可以有效的进行表单验证(手机，邮箱，网址等输入格式的检查)，以及一些数据的爬取，包括字符替换等功能;因此，正则表达式是一项非常强大的表达式语言。</p><h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><p>java基础架包中java.util.regex提供正则表达式相关的类：</p><ul><li>Pattern 表示正则表达式编译器对象。Pattern 类没有提供公共的构造方法。 必须调用公共的静态 compile 方法，它将返回一个 Pattern 对象。</li><li>Matcher 正则表达式的匹配器。 Matcher 没有定义公共的构造方法，需要通过调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</li></ul><p>简单的正则表达式例子：</p><p>手机号: <code>^1[3456789]\\d&#123;9&#125;$</code> </p><p>解析:</p><p>观察以上表达式，被匹配的字符串，必须以数字1开后，后面第二数只能为3,4,5,6,7,8,9中的其中一个，从第三位开始后面一共包含9位数字，并且以数字结尾。</p><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><h3 id="正则表达式组成规范"><a href="#正则表达式组成规范" class="headerlink" title="正则表达式组成规范"></a>正则表达式组成规范</h3><ul><li><p>“.” ：</p><p>用于匹配一个任意的字符</p></li><li><p>“[]”</p><p>为了解决句点符号匹配范围过于广泛这一问题，你可以在方括号（“[]”）里面指定看来有意义的字符。此时，只有方括号里面指定的字符才参与匹配。也就是说，正则表达式“t[aeio]n”只匹配“tan”、“Ten”、“tin”和“ton”。但“Toon”不匹配。</p></li><li><p>“|”</p><p>如果除了上面匹配的所有单词之外，你还想要匹配“toon”，那么，你可以使用“|”操作符。“|”操作符的基本意义就是“或”运算。要匹配“toon”，使用“t(a|e|i|o|oo)n”正则表达式。这里不能使用方扩号，因为方括号只允许匹配单个字符；这里必须使用<strong>圆括号“()”, 它表示一个整体</strong>。</p></li><li><p>“-”</p><p>与表示数字或字母的范围<br>如： [0-9]表示0到9中的其中一个字符,[3-8]表示3到8中的一个字符<br>[b-d3-8]表示b到z或3到8中其中一个字符 [a-z]表示a到z中的其中一个字符</p><p><code>[a-c][0-9]&#123;3&#125;</code>可以匹配a234,b112,c223等。这里的大括号“{}”表示能匹配的字符数量</p></li><li><p>“^”</p><ul><li>直接使用表示以什么开头，”^1asd”,表示以“1”开头</li></ul></li></ul><ul><li><p><strong>-在[]中使用</strong> 即非,用来确定紧靠该符号右边的符号不能出现,</p><p>​    如：<code>[^0-9]</code>表示不可以为0到9<br>​    示例<code> [^A]</code>表示不可以为A的字符</p></li><li><p>$</p></li></ul><h3 id="匹配次数的通配符"><a href="#匹配次数的通配符" class="headerlink" title="匹配次数的通配符"></a>匹配次数的通配符</h3><p>这些符号用来确定紧靠该符号左边的符号出现的次数</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="../img/2019/10/05/zz.png"></p><p>示例</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例1：a*Hello可以匹配以Hello结尾，以0到多个a开头的字符串,如Hello,aHello,aaHello,aaaHello </span><br><span class="line">示例2：MyA*Hello可以匹配以My开头，以Hello结尾，中间可以有0到多个A，如MyAAAHello </span><br><span class="line">示例3：HelloE+World可以匹配以Hello开头，以World结尾，中间可以有1到多个E，如HelloEEWorld </span><br><span class="line">示例4：HelloE?World可以匹配以Hello开头，以World结尾，中间必须有0到1个E</span><br><span class="line">示例5：HelloE&#123;3&#125;World可以匹配以Hello开头，以World结尾，中间必须有3个E</span><br><span class="line">示例6：HelloE&#123;2,4&#125;World可以匹配以Hello开头，以World结尾，中间必须有2到4个E </span><br><span class="line">示例7：Helloabc可以匹配以Hello开头，不能以a或b或c结尾</span><br></pre></td></tr></table></figure><h3 id="快捷符号"><a href="#快捷符号" class="headerlink" title="快捷符号"></a>快捷符号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\d表示 [0-9] </span><br><span class="line">\D表示 [^0-9] </span><br><span class="line">\w表示 [A-Za-z0-9_] </span><br><span class="line">\W表示 [^A-Za-z0-9_] </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File</title>
      <link href="2019/File.html"/>
      <url>2019/File.html</url>
      
        <content type="html"><![CDATA[<h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(File.pathSeparator); <span class="comment">// 分号（String）</span></span><br><span class="line">System.out.println(File.pathSeparatorChar); <span class="comment">// 分号（char）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前系统中对应的路径分隔符，Windows，\。Linux:/</span></span><br><span class="line">System.out.println(File.separator);</span><br></pre></td></tr></table></figure><h2 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取e盘下的a.txt.文件的File对象</span></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;e:\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个文件，true表示成功，false表示存在了就不会再次创建</span></span><br><span class="line"><span class="keyword">boolean</span> flag = f1.createNewFile();</span><br><span class="line">System.out.println(flag);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目录（文件夹）</span></span><br><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">&quot;e:\\file&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag2 = f2.mkdir();</span><br><span class="line">System.out.println(flag2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性创建多层次的目录</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">&quot;e:\\demo\\test\\sen&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag3 = f3.mkdir();</span><br><span class="line">System.out.println(flag3);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断File对象对应的文件是否存在</span></span><br><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">&quot;e:\\data&quot;</span>);</span><br><span class="line">f2.mkdir();</span><br><span class="line">System.out.println(f2.exists());</span><br><span class="line"></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;e:\\data\\test&quot;</span>);</span><br><span class="line">System.out.println(f1.mkdir()); <span class="comment">// 创建文件或者目录是</span></span><br><span class="line"></span><br><span class="line">System.out.println(f1.delete()); <span class="comment">// 删除</span></span><br><span class="line"></span><br><span class="line">String path = f2.getAbsolutePath(); <span class="comment">// 获取文件对象的绝对路径</span></span><br><span class="line">System.out.println(path);</span><br><span class="line"></span><br><span class="line">File file = f2.getAbsoluteFile(); <span class="comment">// 获取文件对象的绝对路径对应的File对象</span></span><br><span class="line">System.out.println(file);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\File\\test.txt&quot;</span>);</span><br><span class="line">System.out.println(f1.length()); <span class="comment">// 获取文件字节数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> time = f1.lastModified(); <span class="comment">// 获取最后一次更新的时间</span></span><br><span class="line">Date lastTime = <span class="keyword">new</span> Date(time); <span class="comment">// 将毫秒数转成Date对象</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyy/MM/dd hh:mm&quot;</span>);</span><br><span class="line">String str = sdf.format(lastTime);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\File&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list:将当前目录下面的所有子文件（夹）的名称以字符串数组形式返回</span></span><br><span class="line">String[] list1 = f1.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// listFiles:将当前目录下面的所有子文件（夹）的名称以File对象数组形式返回</span></span><br><span class="line">File[] listFiles = f1.listFiles();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件过滤</span></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\File&quot;</span>);</span><br><span class="line"></span><br><span class="line">MyFilter myFilter = <span class="keyword">new</span> MyFilter();</span><br><span class="line"><span class="comment">// 2.传进去一个FileFilter对象，指定过滤规则</span></span><br><span class="line">File[] files = f1.listFiles(myFilter);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用类</title>
      <link href="2019/%E5%B8%B8%E7%94%A8%E7%B1%BB.html"/>
      <url>2019/%E5%B8%B8%E7%94%A8%E7%B1%BB.html</url>
      
        <content type="html"><![CDATA[<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//out对象，标准输出对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//in对象，标椎输入对象</span></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//err:用来输出错误信息</span></span><br><span class="line"><span class="comment">//System.err.println(&quot;world&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="comment">//currentTimeMillis():返回的是从1970-1-1 0:0:0.0 到此时此刻的毫秒数</span></span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">System.out.println(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">//exit():退出程序，0：正常退出，非0不正常退出</span></span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;程序结束了&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String介绍"><a href="#String介绍" class="headerlink" title="String介绍"></a>String介绍</h3><ol><li><p>class final String 是一个最终类，不能被继承</p></li><li><p>final char value[]:用于存储字符串中的每个字符</p></li><li><p>字符串是一个不可变的<br>常量池中不会将相同的数据保存多份的</p><p>常量池中的字符串数据也是不可变的</p></li><li><p>通过字面量形式定义的字符串变量，变量里面保存的是字符串数据在常量池中的地址<br>通过new形式创建的字符串变量，变量保存的是在堆区创建的String对象地址，对象中value属性指向字符串数据在常量池中的地址</p></li></ol><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> !!</span></span><br><span class="line"><span class="function">  <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> !!</span></span><br><span class="line"><span class="function">  <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  String <span class="title">toLowerCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  String <span class="title">toUpperCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  String <span class="title">trim</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> !!</span></span><br><span class="line"><span class="function">  <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span></span></span><br><span class="line"><span class="function">  String <span class="title">concat</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span></span></span><br><span class="line"><span class="function">  String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> !!</span></span><br><span class="line"><span class="function">  String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> ：判断字符串是否已什么结尾</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span>：判断字符串是否已什么开头</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span>：是否包含什么   !!</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> ：获取指定str在字符串中的起始下标  !!</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span></span></span><br><span class="line"><span class="function">  String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  String[] <span class="title">split</span><span class="params">(String regex)</span>：按照指定的regex进行字符串分割，进分割后的子串以字符串数组返回  !!</span></span><br></pre></td></tr></table></figure><h3 id="字符串和数组之间的相互转换"><a href="#字符串和数组之间的相互转换" class="headerlink" title="字符串和数组之间的相互转换"></a>字符串和数组之间的相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t3</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">String str = <span class="string">&quot;I love 中国&quot;</span>;</span><br><span class="line"><span class="comment">// 将字符串照指定编码转换成字节数组</span></span><br><span class="line"><span class="comment">// utf8:三个字节表示一个汉字，bgk：两个字节表示一个汉字</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">&quot;utf8&quot;</span>); <span class="comment">// 参数代表编码格式：utf8 gbk</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String str1 = <span class="keyword">new</span> String(bytes, <span class="string">&quot;utf8&quot;</span>); <span class="comment">// 将字节数组按照指定编码转换成字符串</span></span><br><span class="line">System.out.println(str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String str = <span class="string">&quot;I love 中国&quot;</span>;</span><br><span class="line"><span class="comment">// 字符串转换成字节数组</span></span><br><span class="line"><span class="comment">// 编码：人看懂 ---&gt; 电脑看得懂（二进制）</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes(); <span class="comment">// 当前环境默认的编码格式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字节数组转换成字符串</span></span><br><span class="line"><span class="comment">// 解码： 电脑看得懂（二进制）---&gt; 人看懂 </span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(bytes);</span><br><span class="line">System.out.println(str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String str = <span class="string">&quot;I love 中国&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转换成字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] array = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : array) &#123;</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符数组转换成字符串</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(array);</span><br><span class="line">System.out.println(str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>String因为是不可变的，有的时候会带来一些性能问题</p><p>StringBuffer &amp; StringBuilder是可变的，就是说可以在原有基础上进行更改，不用频繁创建字符串对象</p><ul><li>涉及到字符串高频次的操作时，建议使用StringBuffer &amp; StringBuilder<ul><li>StringBuilder：效率更高，但是不是线程安全的</li><li>StringBuffer：效率会低一点，但是是线程安全的</li></ul></li></ul><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>Date:日期</p><p>可以获取相关日期信息，年月日时分秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">System.out.println(date.getTime());<span class="comment">// 获取1970-1-1 0：0:0.0毫秒数</span></span><br><span class="line"></span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure><h4 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h4><p>日期格式化类 format：可以将date对象转成指定格式的字符串 parse：将字符串再转回成date对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">String time = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2019-2-29 2019/9/29 16:16:50</span></span><br><span class="line"><span class="comment">// y:年 、 M：月、 d：日 、 h:时 、 m：分 、 s：秒 、 E:星期</span></span><br><span class="line">SimpleDateFormat sdf2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss E&quot;</span>); <span class="comment">// 指定格式</span></span><br><span class="line">String time2 = sdf2.format(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(time2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串再转回成date对象</span></span><br><span class="line"><span class="comment">// Date date = sdf2.parse(time2);</span></span><br><span class="line">Date date = sdf2.parse(<span class="string">&quot;2019-09-29 16:16:16 星期日&quot;</span>);<span class="comment">// 字符串的格式要和SimpleDateFormat里面指定的格式一致</span></span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar：日历类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过静态方法getInstance()获取对象</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(calendar.get(Calendar.YEAR)); <span class="comment">// 年</span></span><br><span class="line">System.out.println(calendar.get(Calendar.MONTH)); <span class="comment">// 月份从0开始</span></span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(calendar.get(Calendar.HOUR)); <span class="comment">// 12小时制</span></span><br><span class="line">System.out.println(calendar.get(Calendar.HOUR_OF_DAY)); <span class="comment">// 24小时制</span></span><br><span class="line">System.out.println(calendar.get(Calendar.MINUTE)); <span class="comment">// 分</span></span><br><span class="line">System.out.println(calendar.get(Calendar.SECOND)); <span class="comment">// 秒</span></span><br><span class="line"></span><br><span class="line">Date time = calendar.getTime(); <span class="comment">// 获取Date对象</span></span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure><h2 id="算数类"><a href="#算数类" class="headerlink" title="算数类"></a>算数类</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>Math:数学类，提供了很多数学相关的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.PI); <span class="comment">// 圆周率</span></span><br><span class="line"></span><br><span class="line">System.out.println(Math.abs(-<span class="number">12</span>)); <span class="comment">// 取绝对值</span></span><br><span class="line"></span><br><span class="line">System.out.println(Math.ceil(<span class="number">12.1</span>)); <span class="comment">// 向上取整</span></span><br><span class="line">System.out.println(Math.floor(<span class="number">12.6</span>)); <span class="comment">// 向下取整</span></span><br><span class="line">System.out.println(Math.round(<span class="number">12.5</span>)); <span class="comment">// 四舍五入</span></span><br><span class="line"></span><br><span class="line">System.out.println(Math.pow(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 求参数1的参数2次幂</span></span><br><span class="line">System.out.println(Math.sqrt(<span class="number">4</span>)); <span class="comment">// 求平方根</span></span><br><span class="line"></span><br><span class="line">System.out.println(Math.sin(Math.PI/<span class="number">6</span>)); <span class="comment">// 三角函数</span></span><br><span class="line"></span><br><span class="line">System.out.println(Math.max(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 取最大值</span></span><br><span class="line">System.out.println(Math.min(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 取最小值</span></span><br></pre></td></tr></table></figure><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>Random:随机数类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">System.out.println(random.nextInt()); <span class="comment">// 随机整数</span></span><br><span class="line">System.out.println(random.nextInt(<span class="number">10</span>)); <span class="comment">// 获取0 -10 之间的随机数，但不包括10</span></span><br></pre></td></tr></table></figure><h2 id="超级数字"><a href="#超级数字" class="headerlink" title="超级数字"></a>超级数字</h2><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BigInteger可以表示一个超大的整数</span></span><br><span class="line">BigInteger bint1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;10000000000000000000&quot;</span>);</span><br><span class="line">BigInteger bint2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;20000000000000000000&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigInteger data1 = bint1.add(bint2); <span class="comment">// +</span></span><br><span class="line">BigInteger data2 = bint1.subtract(bint2); <span class="comment">// -</span></span><br><span class="line">BigInteger data3 = bint1.multiply(bint2); <span class="comment">// *</span></span><br><span class="line">BigInteger data4 = bint1.divide(bint2);  <span class="comment">// 除法</span></span><br></pre></td></tr></table></figure><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BigDecimal:表示超级小数，并且还能精确显示</span></span><br><span class="line"><span class="comment">// 推荐将小数以字符串的形式传入</span></span><br><span class="line">BigDecimal x = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line">BigDecimal y = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigDecimal data = x.add(y);</span><br><span class="line">BigDecimal data2 = x.subtract(y);</span><br><span class="line">BigDecimal data3 = x.multiply(y);</span><br><span class="line">BigDecimal data4 = x.divide(y);</span><br></pre></td></tr></table></figure><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] data = &#123;<span class="number">52</span>,<span class="number">96</span>,<span class="number">85</span>,<span class="number">45</span>,<span class="number">86</span>,<span class="number">25</span>&#125;;</span><br><span class="line">String[] data2 = &#123;<span class="string">&quot;dfg&quot;</span>,<span class="string">&quot;sfg&quot;</span>,<span class="string">&quot;gre&quot;</span>,<span class="string">&quot;sdfgr&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(data); <span class="comment">// 自然排序（从小到大）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : data) &#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString():可以将数组中的所有元素拼接成一个字符串返回</span></span><br><span class="line">String str1 = Arrays.toString(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组拷贝：参数1：要拷贝的目标数组，参数2新数组的长度</span></span><br><span class="line"><span class="keyword">int</span>[] copy = Arrays.copyOf(data, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h2><p>排序的对象必须实现Comparable接口</p><p>内部调用了重写的compareTo方法进行对象间的比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Goods</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  返回值 &lt; 0：当前对象 &lt; 传入的对象</span></span><br><span class="line"><span class="comment"> *  返回 = 0：当前对象 = 传入的对象</span></span><br><span class="line"><span class="comment"> *  返回值 &gt; 0：当前对象 &gt; 传入的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Goods goods)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> price - goods.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当类实现的Comparable接口指定的比较规则不适用当前情况时，</span></span><br><span class="line"><span class="comment">// 可以在sort方法中传入Comparator对象，设定当前适合的比较规则</span></span><br><span class="line"><span class="comment">// Comparator可以灵活的设定其他比较的规则，这样就不会按照类中默认的比较规则比大小了</span></span><br><span class="line">Arrays.sort(goods, <span class="keyword">new</span> Comparator&lt;Goods&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Goods o1, Goods o2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里就是按照销量来比大小了</span></span><br><span class="line">    <span class="keyword">return</span> o1.xiaoLiang - o2.xiaoLiang;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="2019/%E5%BC%82%E5%B8%B8.html"/>
      <url>2019/%E5%BC%82%E5%B8%B8.html</url>
      
        <content type="html"><![CDATA[<p>写的代码不可能十全十美，有的是会报错，一报错程序立马挂了<br>异常机制：程序中出现了异常，那系统可以将异常捕获并把处理掉，这样程序就不会挂掉，依然往后执行</p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>Throwable</p><ul><li><p>Error</p></li><li><p>Exception</p><ul><li>编译时异常(检查性异常)：需要强制性try catch<ul><li>IOException</li><li>……</li></ul></li><li>运行时异常(非检查性异常)：一般不做处理<ul><li>NullPointerException</li><li>ArithmeticException</li><li>……</li></ul></li></ul><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/09/28/timg.jpg" alt="异常分类"></p></li></ul><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a><strong>try…catch…finally</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;一个抛，一个接&quot;</span></span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">​```</span><br><span class="line">可能抛出异常的代码</span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line">   &#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名)&#123;</span><br><span class="line">   处理异常的代码</span><br><span class="line">   &#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名)&#123;</span><br><span class="line">   处理异常的代码</span><br><span class="line">   &#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名)&#123;</span><br><span class="line">  处理异常的代码</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>获取异常信息的方式：</strong></p><ol><li>getMessage(): 获取抛出的异常信息</li><li>e.printStackTrace(); 在控制台打印出异常的详细信息</li></ol><p><strong>catch</strong></p><p>catch里面的异常类型要和抛出的异常类型一致</p><p>多个catch时，里面的异常类型没有父子关系时，顺序没有要求<br>但是存在父子关系时，父类异常只能放在子类异常下面</p><p><strong>finally</strong></p><ol><li><p>里面的代码不管是否发生异常都会执行 </p></li><li><p>里面的代码会在return之前执行</p></li><li><p>主要用来干什么？</p><p>关闭流 连接 回收资源等。</p></li></ol><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a><strong>throws</strong></h3><p>在发生位置不处理抛出，交给方法的调用者去处理。</p><ol><li>方法内部异常若不能立马处理的，可以通过throws抛出</li><li>throws：可以在方法声明处定义此方法向外抛出的异常，这样就会将异常交给方法的调用者进行处理</li><li>一个方法可以抛出多个异常</li><li>继承时方法的重写问题<ul><li>子类重写父类方法时，抛出异常不能大于父类方法抛出的异常</li><li>若父类方法为抛出异常，子类重写时也不能抛出异常</li></ul></li></ol><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><p>throw:手动抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动抛异常,注意：抛的是异常对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 异常对象一般有两个构造方法，调用带参构造方法可以自定义异常信息</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">&quot;算术异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">  <span class="comment">//System.out.println(&quot;异常：&quot;+e.getMessage());</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义异常继承RuntimeException</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *添加两个构造方法，初始化message</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="2019/%E5%86%85%E9%83%A8%E7%B1%BB.html"/>
      <url>2019/%E5%86%85%E9%83%A8%E7%B1%BB.html</url>
      
        <content type="html"><![CDATA[<p>内部类就是在一个类的内部定义一个类，比如，A类中定义一个B类，那么B类相对于A类来说就称为内部类，而A类相对于B类来说就是外部类。</p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>​    私有的内部类只能在当前的外部类中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> String sex;</span><br><span class="line">  <span class="keyword">public</span> String weight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(money); <span class="comment">// 成员内部类可以直接访问外部类属性</span></span><br><span class="line">    study();<span class="comment">// 成员内部类可以直接访问外部类方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类和内部类中有同名的属性时</span></span><br><span class="line">    System.out.println(Person.<span class="keyword">this</span>.name); <span class="comment">// 访问外部类的name</span></span><br><span class="line">    System.out.println(name);</span><br><span class="line"></span><br><span class="line">    Person.<span class="keyword">this</span>.eat(); <span class="comment">// 调用外部类的eat()</span></span><br><span class="line">    eat();<span class="comment">// 内部的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建成员内部类对象的语法</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 外部类.内部类 名字 = 外部类对象.new 内部类();</span></span><br><span class="line">Person.Dog dog = p.<span class="function">new <span class="title">Dog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>​    静态内部类中可以定义静态的成员</p><p>​    静态内部类中并不能访问外部类中的非静态成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类创建对象</span></span><br><span class="line">Person.Cat cat = <span class="keyword">new</span> Person.Cat();</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>​    定义在方法里面,很少见作为了解</p><p>​    局部内部类只在当前方法有效</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右边部分称之为匿名内部类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * new 抽象类名（接口名）&#123; ... &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 匿名内部类的应用：若只在某一处使用时可采用匿名内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">animal.eat();</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/09/26/nmnbl.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象3</title>
      <link href="2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13.html"/>
      <url>2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13.html</url>
      
        <content type="html"><![CDATA[<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ol><li><p>static：静态的</p></li><li><p>可以修饰哪些：属性、方法、内部类、代码块</p></li><li><p>有了static之后，变量可以分为静态变量和非静态变量</p><ul><li><p>非静态变量：我们又称之为实例变量，每一个对象都会有一套完全独立的非静态变量，每个对象里面的非静态变量若发生更改 ，不会影响到其他对象的非静态变量</p></li><li><p>静态变量：我们又称之为类变量，这个是跟类相关，与类的对象没有关系，这个静态变量将会在当前这个类的所有对象中共享（独此一份）,可以通过类名调用</p></li><li><p>静态变量的初始化时机：在类加载（使用类）的时候就会进行初始化</p></li></ul><p>4.修饰方法</p></li></ol><ul><li>静态方法也是可以直接通过类名调用</li><li>静态方法也是在加载类的时候会提前加载方法</li></ul><blockquote><p>注意：</p><p>静态方法不能访问非静态属性,或者调用非静态方法</p><p>普通方法是可以调用静态属性和静态方法的</p></blockquote><p>5.什么时候用</p><ul><li><p>什么时候用静态变量：</p><p>假如某个变量是不随对象更改而更改的，那就可以采用静态的<br>常量一般也是设置成静态的</p></li><li><p>什么时候用静态方法：</p><p>一般在工具类中，方法一般是设置成静态的，Math、Arrays…<br>在类中如果说要设计操作一个静态属性的方法，那这个方法一般我们也是设置成静态的</p></li></ul><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li><p>final可以修饰变量（常量），一般常量会被设置成：static final</p></li><li><p>final可以修饰方法，方法不可重写</p></li><li><p>final可以修饰类，类不可继承</p></li><li><p>final修饰局部变量</p></li></ul><h2 id="abstract（抽象）"><a href="#abstract（抽象）" class="headerlink" title="abstract（抽象）"></a>abstract（抽象）</h2><p>abstract修饰的类的称之为抽象类。</p><ol><li><p>抽象类里面可以定义属性、方法（普通或者抽象的）；</p></li><li><p>抽象类里面可以定义构造方法；</p></li><li><p>抽象类不能创建对象，只能由子类去继承；</p></li><li><p>若一个类中有抽象方法，那么这个类必须是抽象类，子类中要实现该方法(抽象子类不用实现)；</p><p><strong>抽象方法不包含方法体，不能被private、final修饰。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名([参数列表]);</span><br></pre></td></tr></table></figure></li><li><p>抽象类和抽象方法是不能设置成final的；</p></li><li><p>抽象类里面不一定要包含抽象方法。</p></li></ol><blockquote><p>当我们在设计的时候，对于当前类的某些行为不能在类中确定，可能要在其子类中进行具体的实现，那么此时就可以考虑将当前类设置抽象类，对应的方法就是抽象方法</p></blockquote><h2 id="interface（接口）"><a href="#interface（接口）" class="headerlink" title="interface（接口）"></a>interface（接口）</h2><ol><li><p>接口和类是同等级的</p></li><li><p>关键字：interface</p></li><li><p>接口里面可以定义什么：</p><p>公共的抽象方法</p><p>公共的静态常量，通过接口名调用</p><p>不能定义构造方法，接口不能创建对象</p><p>JDK1.8:可以定义静态方法、默认方法</p></li><li><p>一个类可以同时实现多个接口</p><ul><li>实现多个接口时：calss A implements B,C,D..</li><li>既有继承又有实现接口：class A extends B implements C,D,…</li></ul></li><li><p>接口与接口之间也是可以继承，并且可以多继承</p><p>接口可以多继承：interface A extends B,C,…</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HEIGHT = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> MIN_HEIGHT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口中的方法都是公共抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 即便不写也会默认为公共的抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口不能定义构造方法，接口不能创建对象</span></span><br><span class="line"><span class="comment">// public Fly() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;默认方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于接口的理解认识：</p><p>java里面的继承单继承，但是有的时候难免一个类要继承多个类，这可以通过接口去实现多继承</p><p>哈士奇 extends 狗，加菲猫 extends 猫，<br>哈士奇是不是狗？ 是<br>加菲猫是不是猫？ 是<br>继承表现出来的是 is-a关系，“是不是”</p><p>接口是对一些方法的抽象，接口表现出来的就是“能不能”</p><p>接口本质，就是一套规范，使用它的类必须遵守这套规范</p></blockquote><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/09/25/%E6%8E%A5%E5%8F%A3.png"></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。<br>总结： “套路”</p><h4 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h4><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p><p>实现：<br>1.私有化构造方法<br>2.内部创建对象<br>3.提供公共的方法返回该对象</p><h5 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉模式：上来就给你把对象创建出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wife</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.内部创建对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Wife wife = <span class="keyword">new</span> Wife();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.私有化构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Wife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.提供公共的方法返回该对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Wife <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> wife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉模式：在使用的时候创建对象，在用的时候去创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wife2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、先不创建</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Wife2 wife2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.私有化构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Wife2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、提供公共的方法返回该对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Wife2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 先去判断wife2是否为null</span></span><br><span class="line">      <span class="keyword">if</span>(wife2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">          wife2 = <span class="keyword">new</span> Wife2();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> wife2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>实际使用中基本数据类型可能会需要一些特殊操作，例如与String相互转换，比大小，转换成其他进制等等，像这样常规思路就是定义一些方法来实现这些，Java的开发者已经将这些情况提前考虑到了，所以就设计了基本数据类型对应的一些类，这些类我们称之为包装类，包装类中提供了一些功能方法。</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/09/23/duotai.png"></p><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><ul><li><p>parsexxx():将字符串转换成对应的基本类型</p></li><li><p>valueof():将字符串转换成对应的包装类</p></li><li><p>toString():转换成字符串</p></li></ul><h3 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h3><p>jdk1.5后提供了自动装箱与自动拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer in3 = <span class="number">500</span>; <span class="comment">//自动装箱, new Integer(500)</span></span><br><span class="line"><span class="keyword">int</span> data6 = in3; <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象2</title>
      <link href="2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12.html"/>
      <url>2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12.html</url>
      
        <content type="html"><![CDATA[<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this：this代表当前类的对象</p><ul><li>可以调用类型的属性，构造方法里面。getxxx()方法里面</li><li>调用类中的普通方法</li><li>在一个构造方法中调用另外一个构造方法</li></ul><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>super代表父类的对象</p><ul><li>super调用父类的构造方法，必须在构造方法的第一个</li><li>super必须只能出现在子类的方法或者构造方法中</li><li>super和this不能同时调用构造方法</li></ul><p><strong>this和super的不同：</strong></p><table><thead><tr><th></th><th>this</th><th>super</th></tr></thead><tbody><tr><td>代表的对象不同</td><td>本身调用者这个对象</td><td>代表父类的对象</td></tr><tr><td>前提</td><td>没有继承也可以使用</td><td>只能在继承条件下才可以使用</td></tr><tr><td>构造方法</td><td>本类的构造</td><td>父类的构造</td></tr></tbody></table><h2 id="面向对象的三个主线"><a href="#面向对象的三个主线" class="headerlink" title="面向对象的三个主线"></a>面向对象的三个主线</h2><ul><li>类和对象</li><li>面向对象的三大特性：封装，继承，多态</li><li>关键字：package，import，final，static</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>该暴露的暴露，该隐藏的隐藏</p><p>封装通过访问修饰符进行实现</p><table><thead><tr><th></th><th align="center">本类</th><th align="center">同一个包</th><th align="center">子类</th><th align="center">全局</th></tr></thead><tbody><tr><td>public</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td>protected(受保护的)</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td></tr><tr><td>缺省</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td></tr><tr><td>private</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td><td align="center">N</td></tr></tbody></table><p>package &amp; import</p><p>package（包）：包其实就是文件夹</p><p>项目比较复杂，各个功能模块，会创建很多的类，需要把类分门别类的存放，处理网络请求类，工具类。。。</p><p>相同功能的类放到一个包中</p><p>包的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com:表示商业性的组织，公司</span></span><br><span class="line">com.sen.test</span><br><span class="line"><span class="comment">//org:开源组织</span></span><br><span class="line">org.sen.test</span><br><span class="line"><span class="comment">//edu:教育组织，学校</span></span><br><span class="line">edu.sen.test</span><br><span class="line"><span class="comment">//gov:政府组织，政府相关机构</span></span><br><span class="line">gov.sen.test</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>import:</p><p>项目中各个类是需要相互协作，一个类中要使用另外一个类，但是这两个类不在同一个包中，此时就需要使用import关键字将项目导入当前类中</p><p>顺序：</p><p>package</p><p>import</p><p>class</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>好处：提高代码复用性，提高类的扩展性</p><p>特点：</p><ul><li>子类可以继承父类的属性和方法，private修饰的不能直接调用，但是已经继承</li><li>子类也可以新增属性和行为</li><li>继承是单继承，一个子类只能直接继承一个父类</li></ul><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><ul><li>方法的名字、参数列表、返回值都要跟父类的方法一致</li><li>子类方法的访问权限修饰符不能小于父类的方法</li><li>抛出的异常范围可以被缩小，但不能被扩大</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>子类的构造方法会默认调用父类的无参构造方法</p><p>super：指代父类对象，可以调用父类的属性，构造方法，普通方法</p><h3 id="子类的初始化流程"><a href="#子类的初始化流程" class="headerlink" title="子类的初始化流程"></a>子类的初始化流程</h3><p>创建子类对象时，先创建父类对象，再创建子类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 代码块&#123;&#125;</span></span><br><span class="line"><span class="comment">* 有的时候类中可能存在多个构造方法，并且这些构造方法里面有相同代码片段</span></span><br><span class="line"><span class="comment">* 这个时候可以将这些相同的代码片段定义在代码块中</span></span><br><span class="line"><span class="comment">* 代码块中的代码也是用于初始化属性</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 特性：</span></span><br><span class="line"><span class="comment">* 代码块中的代码先于构造方法执行，并且每次创建对象都会执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>所有类的父类，一个类如果不继承任何类，那么就会继承Object类</p><p>####toString方法</p><ul><li>Object中的toString方法返回的是对象的地址</li><li>一般toString方法重写时，就是将当前类中属性值以字符串形式返回，方便外界查看对象的所有属性值</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指对象的多种形态，使用多态可以提高代码的扩展性，适用性</p><p>使用多态包含的条件</p><ul><li>继承</li><li>方法重写</li><li>向上转型</li></ul><blockquote><p>类中的属性不参与多态性；</p><p>父类引用调用方法时，若子类对该方法进行了重写，那么将执行子类重写后的方法，所以这里体现出多态是运行时多态；</p><p>父类引用不能调用子类新增的属性或者方法；</p></blockquote><p>理解上课的两个例子：《开车》和《数据库驱动类》，<strong>重点在于为什么这样设计，带来的好处，从而明白多态性的使用</strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象1</title>
      <link href="2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11.html"/>
      <url>2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><p>面向过程和面向对象，都是一种设计思想</p><p>面向过程：侧重于实现的具体过程，主要设计到方法（函数）</p><p>面向对象：面向对象是将问题转行成<strong>谁做什么事情（对象干什么）</strong></p><p><strong>怎么将大象放进冰箱？</strong></p><p><strong>面向过程：</strong></p><p>1、开冰箱门</p><p>2、把大象塞进去</p><p>3、关冰箱门</p><p><strong>面向对象：</strong></p><p>存在哪些对象（事物）</p><p>冰箱、大象、人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">冰箱（）&#123;</span><br><span class="line"></span><br><span class="line">冰箱门打开（）&#123;&#125;</span><br><span class="line"></span><br><span class="line">冰箱门关闭（）&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">人（）&#123;</span><br><span class="line"></span><br><span class="line">打开冰箱门（）&#123;&#125;</span><br><span class="line"></span><br><span class="line">赛大象（）&#123;&#125;</span><br><span class="line"></span><br><span class="line">关闭冰箱门（）&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">大象（）&#123;</span><br><span class="line"></span><br><span class="line">喊救命（）&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体过程：</p><p>人.打开冰箱门（）{}</p><p>人.塞大象（）{}</p><p>人.关闭冰箱门（）{}</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象编程（Object-Orientend Programming，OOP）本质是：以类的方式组织代码，以对象的形式（封装）数据</p><p>类（class）：类是对一类事物的一个抽象定义</p><p>对象（Object）：对象是一类事物的具体表现</p><p>手机：小米，华为，oppo</p><p>电脑：联想，华为，华硕，戴尔</p><p>人：亚洲人，非洲人，欧洲人…</p><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">  <span class="comment">//属性（变量）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//行为（方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中的属性和行为具体要看怎么设计，并不是必须要包含。</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line">类名 变量名 = <span class="keyword">new</span> 类名();</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><h3 id="属性和方法的使用"><a href="#属性和方法的使用" class="headerlink" title="属性和方法的使用"></a>属性和方法的使用</h3><p>访问&amp;修改属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象.xxx;</span><br><span class="line">对象.xxx &#x3D; yyy;</span><br></pre></td></tr></table></figure><p>方法的调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.方法();</span><br></pre></td></tr></table></figure><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/09/16/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1.png"></p><h3 id="再看方法"><a href="#再看方法" class="headerlink" title="再看方法"></a>再看方法</h3><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>方法的重载：方法的参数列表不一样（类型或个数），方法名一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jia</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">System.out.println(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jia</span><span class="params">(<span class="keyword">float</span> x,<span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">System.out.println(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jia</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">System.out.println(x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传值-amp-传引用"><a href="#传值-amp-传引用" class="headerlink" title="传值&amp;传引用"></a>传值&amp;传引用</h4><p>传值：方法的参数为基本数据类型，方法中所有进行的更改不会影响原来的实参</p><p>传引用：方法的参数为引用类型，若在方法中更改了引用对应的对象，那么在其他地方在去访问对象是，里面的数据将会有变化</p><pre><code>public class Test5 &#123;    int x;public static void main(String[] args) &#123;            Test5 t = new Test5();    int a = 10;    t.f1(a);    System.out.println(&quot;main：&quot; + a);   /**********************************/    t.x = 100;    System.out.println(t.x);    t.f2(t);    System.out.println(&quot;main:&quot; + t.x);&#125;// 传引用public void f2(Test5 t) &#123;    t.x = 200;    System.out.println(&quot;f2:&quot; + t.x);&#125;// 传值 public void f1(int a) &#123;    a++;    System.out.println(&quot;f1:&quot; + a);&#125;&#125;</code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造方法语法：</span><br><span class="line"></span><br><span class="line"> public 类名([参数列表])&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li>构造方法可以用来创建对象</li><li>带参构造方法可以在创建对象时，通过传入参数将对象的属性进行初始化</li><li>一个类中若没有显示的定义任何构造方法，那么系统将会自动添加一个无参构造方法;</li><li>若手动定义了一个带参构造方法，但是没有定义无参构造方法，那么类的无参构造方法将会被带参构造方法所覆盖</li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="2019/%E6%95%B0%E7%BB%84.html"/>
      <url>2019/%E6%95%B0%E7%BB%84.html</url>
      
        <content type="html"><![CDATA[<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>数组：数组是一种数据结构，可以存放多个数据</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/09/12/box.jpg"></p><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><p>声明并初始化数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 知道数据</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 不知道具体数据</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">// 表示数组的长度为5，但是没有存放具体的数据</span></span><br></pre></td></tr></table></figure><blockquote><p>整数类型数组默认值为0<br>浮点型数组默认值为0.0<br>引用类型的数组默认值为null</p></blockquote><h3 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h3><ul><li>通过下标访问数组元素：数组名[下标值]</li><li>数组下标从0开始，一次递增</li><li>注意：下标值不要超出范围，不然报数组越界异常</li></ul><h3 id="数组的修改"><a href="#数组的修改" class="headerlink" title="数组的修改"></a>数组的修改</h3><p>数组名[下标值] = 新的值</p><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组遍历的另外一种方式</span></span><br><span class="line"><span class="comment">// 没循环一次，就换将数组中对应的一个元素放入到循环变量i中</span></span><br><span class="line"><span class="keyword">int</span>[] score = &#123;<span class="number">55</span>,<span class="number">65</span>,<span class="number">98</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : score) &#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] names = &#123;<span class="string">&quot;小花&quot;</span>,<span class="string">&quot;小黑&quot;</span>,<span class="string">&quot;效率&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (String str : names) &#123;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法的参数为数组"><a href="#方法的参数为数组" class="headerlink" title="方法的参数为数组"></a>方法的参数为数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/09/12/2.png"></p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组：数组里面存放数组</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/09/12/java03_01.png"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] data = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;; <span class="comment">// 二维数组：两行两列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] data2 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;; <span class="comment">// 二维数组：三行两列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] data3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">// 定义一个三行四列的二维数组，但里面只有默认值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] data4 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][]; <span class="comment">// 当前这个二维数组是5行，列数不定</span></span><br></pre></td></tr></table></figure><h3 id="访问修改"><a href="#访问修改" class="headerlink" title="访问修改"></a>访问修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 访问二维数组的元素</span></span><br><span class="line">System.out.println(data[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 修改</span></span><br><span class="line">data[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">50</span>;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">  <span class="comment">// data[i]:获取就是每个子数组的地址值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data[i].length; j++) &#123;</span><br><span class="line">    System.out.println(data[i][j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法</title>
      <link href="2019/%E6%96%B9%E6%B3%95.html"/>
      <url>2019/%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<p>方法：方法就是可以完成一个特定功能的代码片段，可以提高代码的复用性，同时提高代码的维护性以及阅读性</p><p>方法语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回值类型 方法名([参数列表])&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法的分类"><a href="#方法的分类" class="headerlink" title="方法的分类"></a>方法的分类</h2><h3 id="无参无返回值"><a href="#无参无返回值" class="headerlink" title="无参无返回值"></a>无参无返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>void : 表示方法的返回值为空（没有返回值）</p><p>方法名括号中为空时，代表方法没有参数</p></blockquote><h3 id="无参带返回值"><a href="#无参带返回值" class="headerlink" title="无参带返回值"></a>无参带返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带返回值的方法</span></span><br><span class="line"><span class="comment">// 返回值是根据实际需求来定，有没有，有是什么类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;炒菜中...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;宫保鸡丁&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test2 t = <span class="keyword">new</span> Test2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果在调用方法后，你想要得到方法给你返回的结果，那么就需要通过一个变量去接收方法的返回值</span></span><br><span class="line">String name = t.cook();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;客户正在吃&quot;</span> + name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>return后面的数据类型要和方法的返回值类型一致</p></blockquote><h3 id="有参有返回值"><a href="#有参有返回值" class="headerlink" title="有参有返回值"></a>有参有返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 炒菜时需要自己添加配料</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  带参数</span></span><br><span class="line"><span class="comment"> *  方法名(参数类型  参数1,参数类型  参数2,...)&#123;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cook</span><span class="params">(String pl1,String pl2)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 添加配料</span></span><br><span class="line">System.out.println(<span class="string">&quot;添加配料&quot;</span> + pl1);</span><br><span class="line">System.out.println(<span class="string">&quot;添加配料&quot;</span> + pl2);</span><br><span class="line">System.out.println(<span class="string">&quot;炒菜中...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;宫保鸡丁&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法中的参数类型可以不同，根据自己的需求来定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pl1 配料1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pl2 配料2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 炒菜的时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回菜名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cook2</span><span class="params">(String pl1,String pl2,<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 添加配料</span></span><br><span class="line">System.out.println(<span class="string">&quot;添加配料&quot;</span> + pl1);</span><br><span class="line">System.out.println(<span class="string">&quot;添加配料&quot;</span> + pl2);</span><br><span class="line">System.out.println(<span class="string">&quot;炒菜时间为&quot;</span> + time + <span class="string">&quot;分钟&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;炒菜中...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;宫保鸡丁&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Test3 t = <span class="keyword">new</span> Test3();</span><br><span class="line"><span class="comment">// 调用带参数的方法时，要传入对应类型的数据，数量也要一致</span></span><br><span class="line">String name = t.cook(<span class="string">&quot;洋葱&quot;</span>,<span class="string">&quot;青椒&quot;</span>);</span><br><span class="line"></span><br><span class="line">t.cook2(<span class="string">&quot;洋葱&quot;</span>, <span class="string">&quot;青椒&quot;</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参数个数可以多个（尽量不要超过5个，参数过多时有其他解决方案，后面课程介绍）</p><p>参数名不能重复</p><p>参数类型也可以多样，根据自己需求来定</p><p>调用带参数的方法时，要传入对应类型的数据，数量也要一致</p></blockquote><h3 id="有参无返回值"><a href="#有参无返回值" class="headerlink" title="有参无返回值"></a>有参无返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参数无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">(String pl)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;添加配料&quot;</span> + pl);</span><br><span class="line">  System.out.println(<span class="string">&quot;炒菜中...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局变量-amp-局部变量"><a href="#全局变量-amp-局部变量" class="headerlink" title="全局变量 &amp; 局部变量"></a>全局变量 &amp; 局部变量</h2><p>代码块：可以将一对花括号中的代码看作是一个代码块。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>定义在代码块中的变量可以看做是一个局部变量。</p><p><strong>局部变量只能在当前代码块中使用</strong>，出了当前代码块就无法访问到。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>直接声明在类中的变量我们称之为全局变量。</p><p>全局变量在当前类中任何地方都可以使用，例如方法中、循环语句中、if语句中都可访问。</p><h2 id="形参-amp-实参"><a href="#形参-amp-实参" class="headerlink" title="形参 &amp; 实参"></a>形参 &amp; 实参</h2><h3 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h3><p>定义在方法中小括号中的参数叫做方法的形参。</p><p>形参都是属于当前方法的局部变量。</p><p>形参主要用来接收调用方法时传入的参数。</p><h3 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h3><p>实参就是调用方法时传入参数。</p><h2 id="递归（了解）"><a href="#递归（了解）" class="headerlink" title="递归（了解）"></a>递归（了解）</h2><p>方法的递归：一个方法在其方法体中调用自己。（自己调用自己）</p><p>使用递归时，需要设立一个边界条件，让方法满足条件时返回。</p><p>若无边界条件，会无限循环知道栈溢出程序停止运行。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环语句</title>
      <link href="2019/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5.html"/>
      <url>2019/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5.html</url>
      
        <content type="html"><![CDATA[<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * while语法:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * while(条件)&#123;</span></span><br><span class="line"><span class="comment"> *   循环体代码</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 执行过程：</span></span><br><span class="line"><span class="comment"> * 1、判断条件</span></span><br><span class="line"><span class="comment"> * 2、条件成立，则执行一次循环体代码</span></span><br><span class="line"><span class="comment"> * 3、一次循环结束后，重复1、2步骤</span></span><br><span class="line"><span class="comment"> * 4、条件不成立时，将结束循环，执行while后面的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">do &#123;</span></span><br><span class="line"><span class="comment">循环体</span></span><br><span class="line"><span class="comment">&#125;while(条件);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">执行过程：</span></span><br><span class="line"><span class="comment">1、首先先执行一次循环体代码</span></span><br><span class="line"><span class="comment">2、执行完后，判断条件</span></span><br><span class="line"><span class="comment">3、条件成立，执行循环体</span></span><br><span class="line"><span class="comment">4、重复2、3步骤</span></span><br><span class="line"><span class="comment">5、条件不成立结束循环</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 语法格式：</span></span><br><span class="line"><span class="comment"> * for(循环变量;循环条件;循环变量运算)&#123;</span></span><br><span class="line"><span class="comment"> * 循环体</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 执行过程：</span></span><br><span class="line"><span class="comment"> * 1、初始化循环变量</span></span><br><span class="line"><span class="comment"> * 2、判断条件</span></span><br><span class="line"><span class="comment"> * 3、条件成立，执行一次循环体</span></span><br><span class="line"><span class="comment"> * 4、循环一次后，循环变量进行一次运算（+ - / *...）</span></span><br><span class="line"><span class="comment"> * 5、重复2 3 4步骤</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 条件不成立时，则结束for循环</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、break;</span><br><span class="line">可以直接跳出当前整个循环语句（直接结束循环）</span><br><span class="line"></span><br><span class="line">2、continue</span><br><span class="line">可以提前结束此次循环，开始下一次循环</span><br></pre></td></tr></table></figure><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串拼接符"><a href="#字符串拼接符" class="headerlink" title="字符串拼接符 (+)"></a>字符串拼接符 (+)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">100.123</span>;</span><br><span class="line">String y = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// + : 字符串拼接符，可以将某个类型的变量与一个字符串拼接起来，组成一个新的字符串</span></span><br><span class="line">String str = x + y;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分支语句</title>
      <link href="2019/%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5.html"/>
      <url>2019/%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5.html</url>
      
        <content type="html"><![CDATA[<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1、从最上面的if开始判断，若其中某个if成立，则执行当前这个if后面花括号的代码，其他if将不会再执行</span></span><br><span class="line"><span class="comment">* 2、else if可以有多个</span></span><br><span class="line"><span class="comment">* 3、最后的else可有可无，这个根据实际需求来定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>()&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>()&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line">  <span class="keyword">case</span> value1:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> value2:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>key:要判断的一个目标值<br>执行switch后，将会把目标值与case后面的value进行比对，<br>若果相等则执行当前case后面的代码，到break跳出switch<br>若果不相等则会继续与下一个case进行比对<br>若所有case都不匹配，则会执行default中的代码</p><p>注意：<br>1、default可有可无，但是最多只能有一个<br>2、switch括号中的值与case后面的值类型必须一致<br>3、switch括号中的值的类型只能是int、String、枚举<br>4、case后面的值只能是常量值或者常量表达式</p></blockquote><h3 id="枚举Enum（了解）"><a href="#枚举Enum（了解）" class="headerlink" title="枚举Enum（了解）"></a>枚举Enum（了解）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum:表示枚举</span></span><br><span class="line"><span class="comment">// 枚举里面的每个元素都会有一个对应的整数序号，从0开始</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Weeks</span> </span>&#123;</span><br><span class="line">MON,</span><br><span class="line">TUE,</span><br><span class="line">WEN,</span><br><span class="line">TUH,</span><br><span class="line">FRI,</span><br><span class="line">SAT,</span><br><span class="line">SUN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Weeks week = Weeks.TUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (week) &#123;</span><br><span class="line">  <span class="keyword">case</span> MON:</span><br><span class="line">    System.out.println(<span class="string">&quot;星期1&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TUE:</span><br><span class="line">    System.out.println(<span class="string">&quot;星期2&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WEN:</span><br><span class="line">    System.out.println(<span class="string">&quot;星期3&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TUH:</span><br><span class="line">    System.out.println(<span class="string">&quot;星期4&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> FRI:</span><br><span class="line">    System.out.println(<span class="string">&quot;星期5&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SAT:</span><br><span class="line">    System.out.println(<span class="string">&quot;星期6&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SUN:</span><br><span class="line">    System.out.println(<span class="string">&quot;星期7&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="2019/%E8%BF%90%E7%AE%97%E7%AC%A6.html"/>
      <url>2019/%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
      
        <content type="html"><![CDATA[<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><ul><li>+、-、*、/、%、++ (自增1)、– (自减1)</li><li>/：两个int相除时只会获取整数部分</li><li><strong>前置++（–）：先运算后赋值</strong></li><li><strong>后置++（–）：先赋值再运算</strong></li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x += <span class="number">5</span>; <span class="comment">// 等价于x = x + 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换m和n的值</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp = m;</span><br><span class="line">m = n; <span class="comment">// 100</span></span><br><span class="line">n = temp; <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比较运算符:&gt; 、 &lt; 、 &gt;&#x3D; 、 &lt;&#x3D; 、 &#x3D;&#x3D; 、!&#x3D;</span><br><span class="line">比较运算符使用时，会返回相应的结果，结果值类型为boolean</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&amp;&amp;、||、！    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑运算符：并且、或者、非（取反）</span></span><br><span class="line"><span class="comment">// 返回boolean类型结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 并且：&amp;&amp;</span></span><br><span class="line"><span class="comment">// &amp;&amp; : 两边的运算数为boolean类型</span></span><br><span class="line"><span class="comment">// &amp;&amp; : 只要其中一个为false，则最终返回false，除非两个都为true，则返回true</span></span><br><span class="line"><span class="comment">// 判断score1是否大于等于90，并且score2大于等于90</span></span><br><span class="line"><span class="keyword">boolean</span> result1 = score1 &gt;= <span class="number">90</span> &amp;&amp; score2 &gt;= <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 或者： ||</span></span><br><span class="line"><span class="comment">// 只要其中一个为true，则返回true，都为false时才返回false</span></span><br><span class="line"><span class="comment">// 只要其中一个为true，则返回true，都为false时才返回false</span></span><br><span class="line"><span class="keyword">boolean</span> result2 = <span class="number">80</span> &gt;= <span class="number">90</span> || <span class="number">55</span> &gt;= <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 非（取反）：!</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> b2 = !b1;</span><br><span class="line">System.out.println(b2);</span><br></pre></td></tr></table></figure><blockquote><p>&amp;&amp; : 又称为短路与，其中一个条件表达式返回false时，则后面的条件表达式将不会执行</p><p>|| : 又称为短路或，其中一个条件表达式返回true时，则后面的条件表达式将不会执行</p></blockquote><h2 id="条件运算符（三目运算符）"><a href="#条件运算符（三目运算符）" class="headerlink" title="条件运算符（三目运算符）"></a>条件运算符（三目运算符）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 条件运算符（三目运算符）</span><br><span class="line">&#x2F;&#x2F; 语法：条件表达式 ? 表达式1 : 表达式2；</span><br><span class="line">&#x2F;&#x2F;  表达式1 和 表达式2的值类型要一致</span><br><span class="line">&#x2F;&#x2F; 条件表达式为true时，返回表达式1的值，为false时，返回表达式2的值</span><br></pre></td></tr></table></figure><h2 id="位运算符（了解）"><a href="#位运算符（了解）" class="headerlink" title="位运算符（了解）"></a>位运算符（了解）</h2><p>&amp;、|、~、^、&gt;&gt; 、&lt;&lt;</p><ul><li>&amp;:按位与，都为1返回1，否则返回0  </li><li>|:按位或，都为0返回0，否则返回1</li><li>^:异或运算，相同返回0，不同返回1</li><li><code>&gt;&gt;</code>：右移</li><li><code>&lt;&lt;</code>：左移</li><li>~：按位取反</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="2019/JAVA%E5%9F%BA%E7%A1%80.html"/>
      <url>2019/JAVA%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ol><li>JAVA_HOME : C:\Program Files\Java\jdk1.8.0_144</li></ol><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>javac：java程序的编译工具，会生成可执行文件，xxx.Class(字节码文件)</p><p>java：java解释器，通过这个解释器可以执行我们的字节码文件</p><p><strong>先编译生成字节码文件，然后解析执行字节码文件</strong></p><p>JVM：java虚拟机，java程序是在jvm上运行</p><p>JDK：java开发工具包</p><p>JRE：java运行环境</p><p>GC：垃圾回收机制</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><h4 id="文本工具："><a href="#文本工具：" class="headerlink" title="文本工具："></a>文本工具：</h4><p>记事本</p><p>NotePad++</p><p>…</p><h4 id="专业的开发工具"><a href="#专业的开发工具" class="headerlink" title="专业的开发工具"></a>专业的开发工具</h4><p><strong>eclipse</strong></p><p>myeclipse</p><p><strong>IDEA</strong></p><p>…</p><h3 id="eclipse的使用"><a href="#eclipse的使用" class="headerlink" title="eclipse的使用"></a>eclipse的使用</h3><ol><li><p>设置工作空间</p><p>存放java项目的文件夹</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/09/08/eclipse.png"></p></li><li><p>创建项目：file -&gt; new -&gt; java project</p></li><li><p>项目目录结构</p></li></ol><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/09/08/1.png"></p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字：就是java中一些含有特殊含义的名词，java中一共有48+2个关键字，</p><p>其中const、goto是保留字，保留字就是目前预留的关键字，后期更新可能会使用到</p><p><img src= "https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/lhspang/CDN@latest/img/2019/09/08/gjz.png"></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>简单来说：代码中能够自己进行定的都称之为标识符：</p><ol><li>变量名</li></ol><ol start="2"><li>类名</li><li>方法名</li><li>接口名</li><li>包名</li></ol><blockquote><p>注意：</p><ol><li>标识符只能包含英文、数字、下划线(_)、$</li><li>只能以字母或者下划线开头</li><li>标识符不能跟关键字重名</li><li>区分大小写</li><li>变量名命名时，采用驼峰命名法则：变量名由多个单词组成时，第一个单词首字母小写，后面每个单词首字母大写，例如：int   studentAge，String studentName</li><li>类名：采用驼峰命名法则，每个单词首字母都是大写</li><li>名字要做到见名知意</li></ol></blockquote><p>《阿里巴巴Java开发手册（华山版）》</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="1-、基本数据类型"><a href="#1-、基本数据类型" class="headerlink" title="1 、基本数据类型"></a>1 、基本数据类型</h4><h5 id="1-1-数字："><a href="#1-1-数字：" class="headerlink" title="1.1 数字："></a>1.1 数字：</h5><h6 id="整数："><a href="#整数：" class="headerlink" title="整数："></a>整数：</h6><ul><li>byte：1个字节，-128~127</li><li>short：2个字节</li><li>int：4个字节，整数的默认类型</li><li>long：8个字节</li></ul><p>######浮点数：</p><ul><li>float：4个字节</li><li>double：8个字节，浮点数的默认类型</li></ul><h5 id="1-2-字符：char"><a href="#1-2-字符：char" class="headerlink" title="1.2 字符：char"></a>1.2 字符：char</h5><ul><li>用单引号表示，只能包含一个字符</li><li>字符存储时其实存储的是对应的整数值（具体可参考ASCII表）</li></ul><h5 id="1-3-布尔值：boolean"><a href="#1-3-布尔值：boolean" class="headerlink" title="1.3 布尔值：boolean"></a>1.3 布尔值：boolean</h5><ul><li>是有true和false两个值</li></ul><h4 id="2、引用数据类型"><a href="#2、引用数据类型" class="headerlink" title="2、引用数据类型"></a>2、引用数据类型</h4><ol><li>字符串</li><li>数组</li><li>类或者接口</li></ol><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>数据类型大小：byte &lt; short &lt; int &lt; long</p><ol><li>小转大，自动转换</li><li>大转小，需要强制转换，可能会存在数据精度丢失</li></ol><blockquote><p>byte、short、char进行计算式会默认转换成int，再运算</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2019/hello-world.html"/>
      <url>2019/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
